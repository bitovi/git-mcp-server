diff --git a/.gitignore b/.gitignore
index 1e5f8af..9337507 100644
--- a/.gitignore
+++ b/.gitignore
@@ -152,7 +152,6 @@ coverage/
 .parcel-cache/
 
 # Misc
-.DS_Store
 .env.local
 .env.development.local
 .env.test.local
@@ -164,4 +163,4 @@ coverage/
 .history/
 repomix-output*
 mcp-servers.json
-mcp-config.json
\ No newline at end of file
+mcp-config.json
diff --git a/docs/new_git_tools_plan.md b/docs/new_git_tools_plan.md
deleted file mode 100644
index 8265140..0000000
--- a/docs/new_git_tools_plan.md
+++ /dev/null
@@ -1,135 +0,0 @@
-# Git MCP Server - New Tool Implementation Plan
-
-This document outlines the plan for implementing new Git tools in the MCP server, following the established pattern.
-
-## Directory Structure
-
-Each new tool will reside in its own directory under `src/mcp-server/tools/`:
-
-```
-src/mcp-server/tools/
-├── gitRemote/
-│   ├── index.ts
-│   ├── logic.ts
-│   └── registration.ts
-├── gitTag/
-│   ├── index.ts
-│   ├── logic.ts
-│   └── registration.ts
-├── gitStash/
-│   ├── index.ts
-│   ├── logic.ts
-│   └── registration.ts
-├── gitShow/
-│   ├── index.ts
-│   ├── logic.ts
-│   └── registration.ts
-└── gitClean/
-    ├── index.ts
-    ├── logic.ts
-    └── registration.ts
-```
-
-## Tool Definitions and Parameters
-
-### 1. `git_remote`
-
--   **Description**: Manages remote repositories (list, add, remove, show).
--   **Input Schema (`GitRemoteInputSchema`)**:
-    ```typescript
-    z.object({
-      path: z.string().min(1).optional().default('.').describe("Path to the Git repository. Defaults to the session's working directory if set."),
-      mode: z.enum(['list', 'add', 'remove', 'show']).describe("Operation mode: 'list', 'add', 'remove', 'show'"),
-      name: z.string().min(1).optional().describe("Remote name (required for 'add', 'remove', 'show')"),
-      url: z.string().url().optional().describe("Remote URL (required for 'add')"),
-      // Potentially add options like '-f' for add, etc. later if needed
-    })
-    ```
--   **Output (`GitRemoteResult`)**: JSON object varying by mode.
-    -   `list`: `{ success: boolean, remotes: { name: string, fetchUrl: string, pushUrl: string }[] }`
-    -   `add`: `{ success: boolean, message: string }`
-    -   `remove`: `{ success: boolean, message: string }`
-    -   `show`: `{ success: boolean, details: string }` (Raw output from `git remote show`)
-
-### 2. `git_tag`
-
--   **Description**: Manages tags (list, create, delete).
--   **Input Schema (`GitTagInputSchema`)**:
-    ```typescript
-    z.object({
-      path: z.string().min(1).optional().default('.').describe("Path to the Git repository. Defaults to the session's working directory if set."),
-      mode: z.enum(['list', 'create', 'delete']).describe("Operation mode: 'list', 'create', 'delete'"),
-      tagName: z.string().min(1).optional().describe("Tag name (required for 'create', 'delete')"),
-      message: z.string().optional().describe("Annotation message (used with 'create' and annotate=true)"),
-      commitRef: z.string().optional().describe("Commit or object to tag (defaults to HEAD if omitted for 'create')"),
-      annotate: z.boolean().default(false).describe("Create an annotated tag (requires message if true)"),
-      // force: z.boolean().default(false).describe("Force tag creation/update (use with caution)"), // Consider adding later
-      // sign: z.boolean().default(false).describe("GPG sign the tag"), // Consider adding later
-    })
-    ```
--   **Output (`GitTagResult`)**: JSON object varying by mode.
-    -   `list`: `{ success: boolean, tags: string[] }`
-    -   `create`: `{ success: boolean, message: string, tagName: string }`
-    -   `delete`: `{ success: boolean, message: string, tagName: string }`
-
-### 3. `git_stash`
-
--   **Description**: Manages stashed changes (list, apply, pop, drop, save).
--   **Input Schema (`GitStashInputSchema`)**:
-    ```typescript
-    z.object({
-      path: z.string().min(1).optional().default('.').describe("Path to the Git repository. Defaults to the session's working directory if set."),
-      mode: z.enum(['list', 'apply', 'pop', 'drop', 'save']).describe("Operation mode: 'list', 'apply', 'pop', 'drop', 'save'"),
-      stashRef: z.string().optional().describe("Stash reference (e.g., 'stash@{1}') (required for 'apply', 'pop', 'drop')"),
-      message: z.string().optional().describe("Message for 'save' mode"),
-      // includeUntracked: z.boolean().default(false).describe("Include untracked files in 'save' mode (-u)"), // Consider adding later
-      // keepIndex: z.boolean().default(false).describe("Keep staged changes in 'save' mode (--keep-index)"), // Consider adding later
-    })
-    ```
--   **Output (`GitStashResult`)**: JSON object varying by mode.
-    -   `list`: `{ success: boolean, stashes: { ref: string, description: string }[] }`
-    -   `apply`/`pop`: `{ success: boolean, message: string, conflicts: boolean }` (Conflicts might require manual resolution)
-    -   `drop`: `{ success: boolean, message: string }`
-    -   `save`: `{ success: boolean, message: string, stashRef?: string }` (stashRef might not be easily available on save)
-
-### 4. `git_show`
-
--   **Description**: Shows information about Git objects (commits, tags, blobs, trees).
--   **Input Schema (`GitShowInputSchema`)**:
-    ```typescript
-    z.object({
-      path: z.string().min(1).optional().default('.').describe("Path to the Git repository. Defaults to the session's working directory if set."),
-      ref: z.string().min(1).describe("The object reference (commit hash, tag name, branch name, HEAD, etc.) to show."),
-      filePath: z.string().optional().describe("Optional specific file path within the ref to show (e.g., show a file at a specific commit).")
-      // format: z.string().optional().describe("Optional format string for the output"), // Consider adding later
-    })
-    ```
--   **Output (`GitShowResult`)**:
-    -   `{ success: boolean, content: string }` (Returns the raw output of `git show` as text)
-
-### 5. `git_clean`
-
--   **Description**: Removes untracked files from the working directory. **Destructive operation.**
--   **Input Schema (`GitCleanInputSchema`)**:
-    ```typescript
-    z.object({
-      path: z.string().min(1).optional().default('.').describe("Path to the Git repository. Defaults to the session's working directory if set."),
-      force: z.boolean().refine(val => val === true, { message: "Force must be explicitly set to true to execute git clean." }).describe("Required confirmation to run the command. Must be true."),
-      dryRun: z.boolean().default(false).describe("Show what would be deleted without actually deleting (-n)."),
-      directories: z.boolean().default(false).describe("Remove untracked directories in addition to files (-d)."),
-      ignored: z.boolean().default(false).describe("Remove ignored files as well (-x). Use with caution."),
-      // exclude: z.string().optional().describe("Exclude files matching pattern (-e <pattern>)"), // Consider adding later
-    })
-    ```
--   **Output (`GitCleanResult`)**:
-    -   `{ success: boolean, message: string, filesRemoved: string[] }` (List files removed, or files that *would* be removed if dryRun=true)
-
-## Implementation Notes
-
--   All tools will follow the established pattern (`logic.ts`, `registration.ts`, `index.ts`).
--   Input validation will be handled by Zod schemas.
--   Path resolution and sanitization are critical, especially for commands like `git_clean`.
--   Session working directory state will be managed via context accessors/setters passed during registration.
--   Error handling will use `ErrorHandler.tryCatch` and `McpError`.
--   Output will be structured JSON returned as `TextContent` in the `CallToolResult`.
--   The `git_clean` tool will require explicit `force: true` and potentially additional user confirmation mechanisms within the host application due to its destructive nature. The `requires_approval` flag in the host's tool call mechanism should be set to `true` for this tool.
diff --git a/docs/tree.md b/docs/tree.md
index 647afe3..7509dfc 100644
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -1,12 +1,11 @@
 # git-mcp-server - Directory Structure
 
-Generated on: 2025-04-30 05:18:23
+Generated on: 2025-05-01 16:47:43
 
 
 ```
 git-mcp-server
 ├── docs
-    ├── new_git_tools_plan.md
     └── tree.md
 ├── logs
 ├── scripts
diff --git a/package-lock.json b/package-lock.json
index fc89ee0..5a41e77 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -1,18 +1,18 @@
 {
   "name": "@cyanheads/git-mcp-server",
-  "version": "2.0.1",
+  "version": "2.0.2",
   "lockfileVersion": 3,
   "requires": true,
   "packages": {
     "": {
       "name": "@cyanheads/git-mcp-server",
-      "version": "2.0.1",
+      "version": "2.0.2",
       "license": "Apache-2.0",
       "dependencies": {
         "@modelcontextprotocol/sdk": "^1.10.2",
         "@types/node": "^22.15.3",
         "@types/sanitize-html": "^2.15.0",
-        "@types/validator": "13.15.0",
+        "@types/validator": "^13.15.0",
         "dotenv": "^16.5.0",
         "express": "^5.1.0",
         "ignore": "^7.0.4",
@@ -22,14 +22,14 @@
         "tiktoken": "^1.0.21",
         "ts-node": "^10.9.2",
         "typescript": "^5.8.3",
-        "validator": "13.15.0",
+        "validator": "^13.15.0",
         "winston": "^3.17.0",
         "winston-daily-rotate-file": "^5.0.0",
         "yargs": "^17.7.2",
         "zod": "^3.24.3"
       },
       "bin": {
-        "git-mcp-server": "build/index.js"
+        "git-mcp-server": "dist/index.js"
       },
       "devDependencies": {
         "@types/express": "^5.0.1"
diff --git a/package.json b/package.json
index 0cca2d3..db14613 100644
--- a/package.json
+++ b/package.json
@@ -39,7 +39,7 @@
     "@modelcontextprotocol/sdk": "^1.10.2",
     "@types/node": "^22.15.3",
     "@types/sanitize-html": "^2.15.0",
-    "@types/validator": "13.15.0",
+    "@types/validator": "^13.15.0",
     "dotenv": "^16.5.0",
     "express": "^5.1.0",
     "ignore": "^7.0.4",
@@ -49,7 +49,7 @@
     "tiktoken": "^1.0.21",
     "ts-node": "^10.9.2",
     "typescript": "^5.8.3",
-    "validator": "13.15.0",
+    "validator": "^13.15.0",
     "winston": "^3.17.0",
     "winston-daily-rotate-file": "^5.0.0",
     "yargs": "^17.7.2",
diff --git a/src/config/index.ts b/src/config/index.ts
index b7e0e7c..6bff403 100644
--- a/src/config/index.ts
+++ b/src/config/index.ts
@@ -2,7 +2,7 @@ import dotenv from "dotenv";
 import { readFileSync } from "fs";
 import { dirname, join } from "path";
 import { fileURLToPath } from "url";
-import { logger, McpLogLevel } from "../utils/logger.js"; // Import McpLogLevel and logger
+// Removed logger import to break circular dependency
 
 dotenv.config(); // Load environment variables from .env file
 
@@ -57,21 +57,5 @@ export const logLevel = config.logLevel;
  */
 export const environment = config.environment;
 
-// Define valid MCP log levels based on the logger's type definition
-const validMcpLogLevels: McpLogLevel[] = ['debug', 'info', 'notice', 'warning', 'error', 'crit', 'alert', 'emerg'];
-
-// Validate the configured log level
-let validatedMcpLogLevel: McpLogLevel = 'info'; // Default to 'info'
-if (validMcpLogLevels.includes(logLevel as McpLogLevel)) {
-  validatedMcpLogLevel = logLevel as McpLogLevel;
-} else {
-  // Silently default to 'info' if the configured level is invalid.
-  // The logger initialization message will show the actual level being used.
-}
-
-// Initialize the logger with the validated MCP level AFTER config is defined.
-logger.initialize(validatedMcpLogLevel);
-
-// Log initialization message using the logger itself (will go to file and potentially MCP)
-logger.info(`Logger initialized. MCP logging level: ${validatedMcpLogLevel}`);
-logger.debug("Configuration loaded successfully", { config }); // Log loaded config at debug level
+// Logger initialization is now handled in the main application entry point (e.g., src/index.ts)
+// after the config module has been fully loaded.
diff --git a/src/index.ts b/src/index.ts
index c26da91..bd966a5 100644
--- a/src/index.ts
+++ b/src/index.ts
@@ -1,16 +1,30 @@
 #!/usr/bin/env node
-import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js'; // Import McpServer type
-import { config, environment } from "./config/index.js";
-import { initializeAndStartServer } from "./mcp-server/server.js"; // Updated import
-import { logger } from "./utils/logger.js";
-// Import the service instance instead of the standalone function
-import { requestContextService } from "./utils/requestContext.js";
+console.log(">>> index.ts: Top of file"); // DEBUG LOG 1
+
+import http from 'http'; // Import http module
+console.log(">>> index.ts: Imported http"); // DEBUG LOG 2
+import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
+console.log(">>> index.ts: Imported McpServer"); // DEBUG LOG 3
+import { config, environment, logLevel } from "./config/index.js"; // Import logLevel from config
+console.log(">>> index.ts: Imported config, environment, logLevel"); // DEBUG LOG 4
+import { initializeAndStartServer } from "./mcp-server/server.js";
+console.log(">>> index.ts: Imported initializeAndStartServer"); // DEBUG LOG 5
+// Import utils from barrel
+import { logger, McpLogLevel } from './utils/index.js'; // Import McpLogLevel type
+// Import utils from barrel
+import { requestContextService } from './utils/index.js';
 
 /**
- * The main MCP server instance.
+ * The main MCP server instance (used for stdio transport).
  * @type {McpServer | undefined}
  */
-let server: McpServer | undefined;
+let mcpServerInstance: McpServer | undefined;
+
+/**
+ * The main HTTP server instance (used for http transport).
+ * @type {http.Server | undefined}
+ */
+let httpServerInstance: http.Server | undefined;
 
 /**
  * Gracefully shuts down the main MCP server.
@@ -19,24 +33,51 @@ let server: McpServer | undefined;
  * @param signal - The signal or event name that triggered the shutdown (e.g., "SIGTERM", "uncaughtException").
  */
 const shutdown = async (signal: string) => {
-  // Define context for the shutdown operation
+  const transportType = (process.env.MCP_TRANSPORT_TYPE || 'stdio').toLowerCase();
   const shutdownContext = {
     operation: 'Shutdown',
     signal,
+    transport: transportType,
   };
 
   logger.info(`Received ${signal}. Starting graceful shutdown...`, shutdownContext);
 
   try {
-    // Close the main MCP server
-    if (server) {
-      logger.info("Closing main MCP server...", shutdownContext);
-      await server.close();
-      logger.info("Main MCP server closed successfully", shutdownContext);
-    } else {
-      logger.warning("Server instance not found during shutdown.", shutdownContext);
+    let closePromise: Promise<void> = Promise.resolve();
+
+    if (transportType === 'stdio') {
+      // Close the main MCP server instance for stdio
+      if (mcpServerInstance) {
+        logger.info("Closing main MCP server (stdio)...", shutdownContext);
+        closePromise = mcpServerInstance.close();
+      } else {
+        logger.warning("Stdio MCP server instance not found during shutdown.", shutdownContext);
+      }
+    } else if (transportType === 'http') {
+      // Close the main HTTP server listener for http
+      if (httpServerInstance) {
+        logger.info("Closing main HTTP server listener...", shutdownContext);
+        closePromise = new Promise((resolve, reject) => {
+          httpServerInstance!.close((err) => {
+            if (err) {
+              logger.error("Error closing HTTP server listener", { ...shutdownContext, error: err.message });
+              reject(err);
+            } else {
+              logger.info("Main HTTP server listener closed successfully", shutdownContext);
+              resolve();
+            }
+          });
+        });
+      } else {
+        logger.warning("HTTP server instance not found during shutdown.", shutdownContext);
+      }
+      // Note: Individual session transports (StreamableHTTPServerTransport) are closed
+      // when the client disconnects or sends a DELETE request, managed in httpTransport.ts.
     }
 
+    // Wait for the appropriate server/listener to close
+    await closePromise;
+
     logger.info("Graceful shutdown completed successfully", shutdownContext);
     process.exit(0);
   } catch (error) {
@@ -56,7 +97,25 @@ const shutdown = async (signal: string) => {
  * and registers signal handlers for graceful shutdown and error handling.
  */
 const start = async () => {
-  // Create application-level request context using the service instance
+  console.log(">>> index.ts: Entering start() function"); // DEBUG LOG 6
+  // --- Initialize Logger FIRST ---
+  console.log(">>> index.ts: Preparing to initialize logger"); // DEBUG LOG 7
+  // Define valid MCP log levels based on the logger's type definition
+  const validMcpLogLevels: McpLogLevel[] = ['debug', 'info', 'notice', 'warning', 'error', 'crit', 'alert', 'emerg'];
+  let validatedMcpLogLevel: McpLogLevel = 'info'; // Default to 'info'
+  if (validMcpLogLevels.includes(logLevel as McpLogLevel)) {
+    validatedMcpLogLevel = logLevel as McpLogLevel;
+  } else {
+    // Use console.warn as logger isn't ready yet
+    console.warn(`Invalid MCP_LOG_LEVEL "${logLevel}" found in config. Defaulting to "info".`);
+  }
+  // Initialize the logger singleton instance with the validated level.
+  logger.initialize(validatedMcpLogLevel);
+  console.log(">>> index.ts: logger.initialize() called"); // DEBUG LOG 8
+  // Now it's safe to use the logger.
+
+  // --- Start Application ---
+  console.log(">>> index.ts: Preparing to start application logic"); // DEBUG LOG 9
   const transportType = (process.env.MCP_TRANSPORT_TYPE || 'stdio').toLowerCase();
   const startupContext = requestContextService.createRequestContext({
     operation: `ServerStartup_${transportType}`, // Include transport in operation name
@@ -71,23 +130,25 @@ const start = async () => {
     // Initialize the server instance and start the selected transport
     logger.debug("Initializing and starting MCP server transport", startupContext);
 
-    // Start the server transport. For stdio, this returns the server instance.
-    // For http, it sets up the listener and returns void (or potentially the http.Server).
-    // We only need to store the instance for stdio shutdown.
-    const potentialServerInstance = await initializeAndStartServer();
-    if (transportType === 'stdio' && potentialServerInstance instanceof McpServer) {
-        server = potentialServerInstance; // Store only for stdio
+    // Start the server transport. This returns the McpServer instance for stdio
+    // or the http.Server instance for http.
+    const serverOrHttpInstance = await initializeAndStartServer();
+
+    if (transportType === 'stdio' && serverOrHttpInstance instanceof McpServer) {
+        mcpServerInstance = serverOrHttpInstance; // Store McpServer for stdio shutdown
+        logger.debug("Stored McpServer instance for stdio transport.", startupContext);
+    } else if (transportType === 'http' && serverOrHttpInstance instanceof http.Server) {
+        httpServerInstance = serverOrHttpInstance; // Store http.Server for http shutdown
+        logger.debug("Stored http.Server instance for http transport.", startupContext);
     } else {
-        // For HTTP, server instances are managed per-session in server.ts
-        // The main http server listener keeps the process alive.
-        // Shutdown for HTTP needs to handle closing the main http server.
-        // We might need to return the httpServer from initializeAndStartServer if
-        // we want to close it explicitly here during shutdown.
-        // For now, we don't store anything globally for HTTP transport.
+        // This case should ideally not happen if initializeAndStartServer works correctly
+        logger.warning("initializeAndStartServer did not return the expected instance type.", {
+            ...startupContext,
+            instanceType: typeof serverOrHttpInstance
+        });
     }
 
-
-    // If initializeAndStartServer failed, it would have thrown an error,
+    // If initializeAndStartServer failed internally, it would have thrown an error,
     // and execution would jump to the outer catch block.
 
     logger.info(`${config.mcpServerName} is running with ${transportType} transport`, {
diff --git a/src/mcp-server/server.ts b/src/mcp-server/server.ts
index 1375b83..c54c58a 100644
--- a/src/mcp-server/server.ts
+++ b/src/mcp-server/server.ts
@@ -1,50 +1,42 @@
 /**
  * @fileoverview Main entry point for the MCP (Model Context Protocol) server.
- * This file sets up the server instance, configures the transport layer (stdio or HTTP),
- * registers resources and tools, and handles incoming MCP requests.
- * It supports both standard input/output communication and HTTP-based communication
- * with Server-Sent Events (SSE) for streaming responses.
+ * This file sets up the server instance, registers resources and tools,
+ * and orchestrates the connection to the appropriate transport layer (stdio or HTTP).
  */
 
+import http from 'http'; // Import http module
 import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
-import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
-import { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp.js';
-import { isInitializeRequest } from '@modelcontextprotocol/sdk/types.js';
-import express, { NextFunction, Request, Response } from 'express';
-import http from 'http';
-import { randomUUID } from 'node:crypto';
 import { config, environment } from '../config/index.js';
-import { ErrorHandler } from '../utils/errorHandler.js';
-import { logger } from '../utils/logger.js';
-import { requestContextService } from '../utils/requestContext.js';
-import { registerGitAddTool } from './tools/gitAdd/index.js'; // Import git_add
-import { initializeGitBranchStateAccessors, registerGitBranchTool } from './tools/gitBranch/index.js'; // Import git_branch
-import { initializeGitCheckoutStateAccessors, registerGitCheckoutTool } from './tools/gitCheckout/index.js'; // Import git_checkout
-import { initializeGitCherryPickStateAccessors, registerGitCherryPickTool } from './tools/gitCherryPick/index.js'; // Import git_cherry_pick
-import { initializeGitCleanStateAccessors, registerGitCleanTool } from './tools/gitClean/index.js'; // Import git_clean
-import { initializeGitClearWorkingDirStateAccessors, registerGitClearWorkingDirTool } from './tools/gitClearWorkingDir/index.js'; // Import git_clear_working_dir
-import { registerGitCloneTool } from './tools/gitClone/index.js'; // Import git_clone
-import { registerGitCommitTool } from './tools/gitCommit/index.js'; // Import git_commit
-import { initializeGitDiffStateAccessors, registerGitDiffTool } from './tools/gitDiff/index.js'; // Import git_diff
-import { initializeGitFetchStateAccessors, registerGitFetchTool } from './tools/gitFetch/index.js'; // Import git_fetch
-import { registerGitInitTool } from './tools/gitInit/index.js'; // Import git_init
-import { initializeGitLogStateAccessors, registerGitLogTool } from './tools/gitLog/index.js'; // Import git_log
-import { initializeGitMergeStateAccessors, registerGitMergeTool } from './tools/gitMerge/index.js'; // Import git_merge
-import { initializeGitPullStateAccessors, registerGitPullTool } from './tools/gitPull/index.js'; // Import git_pull
-import { initializeGitPushStateAccessors, registerGitPushTool } from './tools/gitPush/index.js'; // Import git_push
-import { initializeGitRebaseStateAccessors, registerGitRebaseTool } from './tools/gitRebase/index.js'; // Import git_rebase
-import { initializeGitRemoteStateAccessors, registerGitRemoteTool } from './tools/gitRemote/index.js'; // Import git_remote
-import { initializeGitResetStateAccessors, registerGitResetTool } from './tools/gitReset/index.js'; // Import git_reset
-import { initializeGitSetWorkingDirStateAccessors, registerGitSetWorkingDirTool } from './tools/gitSetWorkingDir/index.js'; // Import git_set_working_dir
-import { initializeGitShowStateAccessors, registerGitShowTool } from './tools/gitShow/index.js'; // Import git_show
-import { initializeGitStashStateAccessors, registerGitStashTool } from './tools/gitStash/index.js'; // Import git_stash
-import { registerGitStatusTool } from './tools/gitStatus/index.js'; // Import git_status
-import { initializeGitTagStateAccessors, registerGitTagTool } from './tools/gitTag/index.js'; // Import git_tag
-// --- Import Accessor Inits ---
-import { initializeGitAddStateAccessors } from './tools/gitAdd/index.js'; // Import add accessor init
-import { initializeGitCommitStateAccessors } from './tools/gitCommit/index.js'; // Import commit accessor init
-import { initializeGitStatusStateAccessors } from './tools/gitStatus/index.js'; // Import status accessor init
-
+// Import utils from the main barrel file
+import { ErrorHandler, logger, requestContextService } from '../utils/index.js';
+// Import transport functions
+import { startHttpTransport } from './transports/httpTransport.js';
+import { connectStdioTransport } from './transports/stdioTransport.js';
+
+// --- Import Tool Registrations ---
+import { registerGitAddTool } from './tools/gitAdd/index.js';
+import { registerGitBranchTool } from './tools/gitBranch/index.js';
+import { registerGitCheckoutTool } from './tools/gitCheckout/index.js';
+import { registerGitCherryPickTool } from './tools/gitCherryPick/index.js';
+import { registerGitCleanTool } from './tools/gitClean/index.js';
+import { registerGitClearWorkingDirTool } from './tools/gitClearWorkingDir/index.js';
+import { registerGitCloneTool } from './tools/gitClone/index.js';
+import { registerGitCommitTool } from './tools/gitCommit/index.js';
+import { registerGitDiffTool } from './tools/gitDiff/index.js';
+import { registerGitFetchTool } from './tools/gitFetch/index.js';
+import { registerGitInitTool } from './tools/gitInit/index.js';
+import { registerGitLogTool } from './tools/gitLog/index.js';
+import { registerGitMergeTool } from './tools/gitMerge/index.js';
+import { registerGitPullTool } from './tools/gitPull/index.js';
+import { registerGitPushTool } from './tools/gitPush/index.js';
+import { registerGitRebaseTool } from './tools/gitRebase/index.js';
+import { registerGitRemoteTool } from './tools/gitRemote/index.js';
+import { registerGitResetTool } from './tools/gitReset/index.js';
+import { registerGitSetWorkingDirTool } from './tools/gitSetWorkingDir/index.js';
+import { registerGitShowTool } from './tools/gitShow/index.js';
+import { registerGitStashTool } from './tools/gitStash/index.js';
+import { registerGitStatusTool } from './tools/gitStatus/index.js';
+import { registerGitTagTool } from './tools/gitTag/index.js';
 
 // --- Configuration Constants ---
 
@@ -55,97 +47,6 @@ import { initializeGitStatusStateAccessors } from './tools/gitStatus/index.js';
  */
 const TRANSPORT_TYPE = (process.env.MCP_TRANSPORT_TYPE || 'stdio').toLowerCase();
 
-/**
- * The port number for the HTTP transport, configured via the MCP_HTTP_PORT environment variable.
- * Defaults to 3000 if the variable is not set or invalid.
- * @constant {number} HTTP_PORT - The port number for the HTTP server.
- */
-const HTTP_PORT = process.env.MCP_HTTP_PORT ? parseInt(process.env.MCP_HTTP_PORT, 10) : 3000;
-
-/**
- * The host address for the HTTP transport, configured via the MCP_HTTP_HOST environment variable.
- * Defaults to '127.0.0.1' (localhost) if the variable is not set.
- * @constant {string} HTTP_HOST - The host address for the HTTP server.
- */
-const HTTP_HOST = process.env.MCP_HTTP_HOST || '127.0.0.1';
-
-/**
- * The specific endpoint path for handling MCP requests over HTTP.
- * @constant {string} MCP_ENDPOINT_PATH - The URL path for MCP communication.
- */
-const MCP_ENDPOINT_PATH = '/mcp';
-
-/**
- * The maximum number of attempts to find an available port if the initial HTTP_PORT is in use.
- * The server will try `HTTP_PORT`, `HTTP_PORT + 1`, ..., `HTTP_PORT + MAX_PORT_RETRIES`.
- * @constant {number} MAX_PORT_RETRIES - Maximum retry attempts for port binding.
- */
-const MAX_PORT_RETRIES = 15;
-
-/**
- * A record (dictionary/map) to store active HTTP transport instances, keyed by their session ID.
- * This allows associating incoming HTTP requests with the correct ongoing MCP session.
- * @type {Record<string, StreamableHTTPServerTransport>}
- */
-const httpTransports: Record<string, StreamableHTTPServerTransport> = {};
-
-/**
- * Stores the current working directory setting for each active HTTP session.
- * Keyed by session ID. Undefined means no specific working directory is set for the session.
- * @type {Record<string, string | undefined>}
- */
-const sessionWorkingDirectories: Record<string, string | undefined> = {};
-
-
-/**
- * Checks if an incoming HTTP request's origin header is permissible based on configuration.
- * It considers the `MCP_ALLOWED_ORIGINS` environment variable and whether the server
- * is bound to a loopback address (localhost). If allowed, it sets appropriate
- * Cross-Origin Resource Sharing (CORS) headers on the response.
- *
- * Security Note: Carefully configure `MCP_ALLOWED_ORIGINS` in production environments
- * to prevent unauthorized websites from interacting with the MCP server.
- *
- * @param {Request} req - The Express request object, containing headers like 'origin'.
- * @param {Response} res - The Express response object, used to set CORS headers.
- * @returns {boolean} Returns `true` if the origin is allowed, `false` otherwise.
- */
-function isOriginAllowed(req: Request, res: Response): boolean {
-  const origin = req.headers.origin;
-  // Use req.hostname which correctly considers the Host header or falls back
-  const host = req.hostname;
-  // Check if the server is effectively bound only to loopback addresses
-  const isLocalhostBinding = ['127.0.0.1', '::1', 'localhost'].includes(host);
-  // Retrieve allowed origins from environment variable, split into an array
-  const allowedOrigins = process.env.MCP_ALLOWED_ORIGINS?.split(',') || [];
-
-  // Determine if the origin is allowed:
-  // 1. The origin header is present AND is in the configured allowed list.
-  // OR
-  // 2. The server is bound to localhost AND the origin header is missing or 'null' (common for local file access or redirects).
-  const allowed = (origin && allowedOrigins.includes(origin)) || (isLocalhostBinding && (!origin || origin === 'null'));
-
-  if (allowed && origin) {
-    // If allowed and an origin was provided, set CORS headers to allow the specific origin.
-    res.setHeader('Access-Control-Allow-Origin', origin);
-    // Allow necessary HTTP methods for MCP communication.
-    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, DELETE, OPTIONS');
-    // Allow standard MCP headers and Content-Type. Last-Event-ID is for SSE resumption.
-    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Mcp-Session-Id, Last-Event-ID');
-    // Set credentials allowance if needed (e.g., if cookies or authentication headers are involved).
-    res.setHeader('Access-Control-Allow-Credentials', 'true'); // Adjust if using credentials
-  } else if (allowed && !origin) {
-     // Origin is allowed (e.g., localhost binding with missing/null origin), but no origin header to echo back.
-     // No specific CORS headers needed in this case as there's no origin to restrict/allow.
-  } else if (!allowed && origin) {
-    // Log a warning if an origin was provided but is not allowed.
-    logger.warning(`Origin denied: ${origin}`, { operation: 'isOriginAllowed', origin, host, allowedOrigins, isLocalhostBinding });
-  }
-  // Note: If !allowed and !origin, no action/logging is needed.
-
-  return allowed;
-}
-
 
 /**
  * Creates and configures a new instance of the McpServer.
@@ -174,40 +75,41 @@ async function createMcpServerInstance(): Promise<McpServer> {
   // Capabilities inform the client about what features the server supports (e.g., logging).
   const server = new McpServer(
     { name: config.mcpServerName, version: config.mcpServerVersion },
-    { capabilities: { logging: {}, tools: { listChanged: true } } }
+    // Declare capabilities. listChanged: true informs client that tool/resource lists can change dynamically.
+    { capabilities: { logging: {}, tools: { listChanged: true } } } // Removed resources capability as none are registered
   );
 
   try {
     // Register all available tools with the server instance.
     // These functions typically call `server.tool()`.
-    await registerGitAddTool(server); // Register git_add tool
-    await registerGitBranchTool(server); // Added unified git_branch registration
-    await registerGitCheckoutTool(server); // Register git_checkout tool
-    await registerGitCherryPickTool(server); // Added git_cherry_pick registration
-    await registerGitCleanTool(server); // Register git_clean tool
-    await registerGitClearWorkingDirTool(server); // Register the git_clear_working_dir tool
-    await registerGitCloneTool(server); // Added clone registration
-    await registerGitCommitTool(server); // Register git_commit tool
-    await registerGitDiffTool(server); // Register git_diff tool
-    await registerGitFetchTool(server); // Register git_fetch tool
-    await registerGitInitTool(server); // Added init registration
-    await registerGitLogTool(server); // Register git_log tool
-    await registerGitMergeTool(server); // Register git_merge tool
-    await registerGitPullTool(server); // Register git_pull tool
-    await registerGitPushTool(server); // Register git_push tool
-    await registerGitRebaseTool(server); // Added git_rebase registration
-    await registerGitRemoteTool(server); // Register git_remote tool
-    await registerGitResetTool(server); // Register git_reset tool
-    await registerGitSetWorkingDirTool(server); // Register git_set_working_dir tool
-    await registerGitShowTool(server); // Register git_show tool
-    await registerGitStashTool(server); // Register git_stash tool
-    await registerGitStatusTool(server); // Register git_status tool
-    await registerGitTagTool(server); // Register git_tag tool
+    await registerGitAddTool(server);
+    await registerGitBranchTool(server);
+    await registerGitCheckoutTool(server);
+    await registerGitCherryPickTool(server);
+    await registerGitCleanTool(server);
+    await registerGitClearWorkingDirTool(server);
+    await registerGitCloneTool(server);
+    await registerGitCommitTool(server);
+    await registerGitDiffTool(server);
+    await registerGitFetchTool(server);
+    await registerGitInitTool(server);
+    await registerGitLogTool(server);
+    await registerGitMergeTool(server);
+    await registerGitPullTool(server);
+    await registerGitPushTool(server);
+    await registerGitRebaseTool(server);
+    await registerGitRemoteTool(server);
+    await registerGitResetTool(server);
+    await registerGitSetWorkingDirTool(server);
+    await registerGitShowTool(server);
+    await registerGitStashTool(server);
+    await registerGitStatusTool(server);
+    await registerGitTagTool(server);
     logger.info('All Git tools registered successfully', context);
 
   } catch (err) {
     // Log and re-throw any errors during registration, as the server cannot function correctly without them.
-    logger.error('Failed to register resources/tools', {
+    logger.error('Failed to register tools', {
       ...context,
       error: err instanceof Error ? err.message : String(err),
     });
@@ -217,374 +119,37 @@ async function createMcpServerInstance(): Promise<McpServer> {
   return server;
 }
 
-/**
- * Attempts to start the Node.js HTTP server on a specified port and host.
- * If the initial port is already in use (EADDRINUSE error), it increments the port
- * number and retries, up to a maximum number of retries (`maxRetries`).
- *
- * @async
- * @param {http.Server} serverInstance - The Node.js HTTP server instance to start.
- * @param {number} initialPort - The first port number to attempt binding to.
- * @param {string} host - The host address to bind to (e.g., '127.0.0.1').
- * @param {number} maxRetries - The maximum number of additional ports to try (initialPort + 1, initialPort + 2, ...).
- * @param {Record<string, any>} context - Logging context to associate with log messages.
- * @returns {Promise<number>} A promise that resolves with the port number the server successfully bound to.
- * @throws {Error} Rejects if the server fails to bind to any port after all retries, or if a non-EADDRINUSE error occurs.
- */
-function startHttpServerWithRetry(
-  serverInstance: http.Server,
-  initialPort: number,
-  host: string,
-  maxRetries: number,
-  context: Record<string, any>
-): Promise<number> {
-  return new Promise(async (resolve, reject) => {
-    let lastError: Error | null = null;
-    // Loop through ports: initialPort, initialPort + 1, ..., initialPort + maxRetries
-    for (let i = 0; i <= maxRetries; i++) {
-      const currentPort = initialPort + i;
-      try {
-        // Attempt to listen on the current port and host.
-        await new Promise<void>((listenResolve, listenReject) => {
-          serverInstance.listen(currentPort, host, () => {
-            // If listen succeeds immediately, log the success and resolve the inner promise.
-            const serverAddress = `http://${host}:${currentPort}${MCP_ENDPOINT_PATH}`;
-            logger.info(`HTTP transport listening at ${serverAddress}`, { ...context, port: currentPort, address: serverAddress });
-            listenResolve();
-          }).on('error', (err: NodeJS.ErrnoException) => {
-            // If an error occurs during listen (e.g., EADDRINUSE), reject the inner promise.
-            listenReject(err);
-          });
-        });
-        // If the inner promise resolved (listen was successful), resolve the outer promise with the port used.
-        resolve(currentPort);
-        return; // Exit the loop and the function.
-      } catch (err: any) {
-        lastError = err; // Store the error for potential final rejection message.
-        if (err.code === 'EADDRINUSE') {
-          // If the port is in use, log a warning and continue to the next iteration.
-          logger.warning(`Port ${currentPort} already in use, retrying... (${i + 1}/${maxRetries + 1})`, { ...context, port: currentPort });
-          // Optional delay before retrying to allow the other process potentially release the port.
-          await new Promise(res => setTimeout(res, 100));
-        } else {
-          // If a different error occurred (e.g., permission denied), log it and reject immediately.
-          logger.error(`Failed to bind to port ${currentPort}: ${err.message}`, { ...context, port: currentPort, error: err.message });
-          reject(err);
-          return; // Exit the loop and the function.
-        }
-      }
-    }
-    // If the loop completes without successfully binding to any port.
-    logger.error(`Failed to bind to any port after ${maxRetries + 1} attempts. Last error: ${lastError?.message}`, { ...context, initialPort, maxRetries, error: lastError?.message });
-    reject(lastError || new Error('Failed to bind to any port after multiple retries.'));
-  });
-}
-
 
 /**
  * Sets up and starts the MCP transport layer based on the `TRANSPORT_TYPE` constant.
- *
- * If `TRANSPORT_TYPE` is 'http':
- * - Creates an Express application.
- * - Configures middleware for JSON parsing and CORS handling (using `isOriginAllowed`).
- * - Defines endpoints (`POST`, `GET`, `DELETE` at `MCP_ENDPOINT_PATH`) to handle MCP requests:
- *   - `POST`: Handles initialization requests (creating new sessions/transports) and subsequent message requests for existing sessions.
- *   - `GET`: Handles establishing the Server-Sent Events (SSE) connection for streaming responses.
- *   - `DELETE`: Handles session termination requests.
- * - Manages session lifecycles using the `httpTransports` map.
- * - Starts the HTTP server using `startHttpServerWithRetry`.
- *
- * If `TRANSPORT_TYPE` is 'stdio':
- * - Creates a single `McpServer` instance.
- * - Creates a `StdioServerTransport`.
- * - Connects the server and transport to process messages via standard input/output.
- * - Returns the created `McpServer` instance.
+ * Delegates the actual transport setup and connection logic to specific functions
+ * imported from the `transports/` directory.
  *
  * @async
- * @returns {Promise<McpServer | void>} For 'stdio' transport, returns the `McpServer` instance. For 'http' transport, returns `void` as the server runs indefinitely.
+ * @returns {Promise<McpServer | http.Server>} For 'stdio' transport, returns the `McpServer` instance. For 'http' transport, returns the running `http.Server` instance.
  * @throws {Error} Throws an error if the transport type is unsupported, or if server creation/connection fails.
  */
-async function startTransport(): Promise<McpServer | void> {
+async function startTransport(): Promise<McpServer | http.Server> {
   const context = { operation: 'startTransport', transport: TRANSPORT_TYPE };
   logger.info(`Starting transport: ${TRANSPORT_TYPE}`, context);
 
-  // Variable to hold the working directory for the single stdio session.
-  // Declared here so it's accessible in the closure of setWorkingDirectoryFn.
-  let stdioWorkingDirectory: string | undefined;
-
-  // --- Define State Accessor Functions ---
-  // These functions provide a bridge between the tool registration logic and the transport-specific state.
-
-  const setWorkingDirectoryFn = (sessionId: string | undefined, path: string): void => {
-    if (TRANSPORT_TYPE === 'http') {
-      if (sessionId && sessionId in sessionWorkingDirectories) {
-        sessionWorkingDirectories[sessionId] = path;
-        logger.debug(`Set working directory for HTTP session ${sessionId} to ${path}`, { ...context, sessionId });
-      } else {
-        logger.error(`Attempted to set working directory for unknown HTTP session: ${sessionId}`, { ...context, sessionId });
-      }
-    } else if (TRANSPORT_TYPE === 'stdio') {
-      // For stdio, we modify the variable directly (assuming it's accessible in this scope)
-      stdioWorkingDirectory = path; // This relies on stdioWorkingDirectory being declared below
-      logger.debug(`Set working directory for stdio session to ${path}`, context);
-    }
-  };
-
-  const clearWorkingDirectoryFn = (sessionId: string | undefined): void => {
-    if (TRANSPORT_TYPE === 'http') {
-      if (sessionId && sessionId in sessionWorkingDirectories) {
-        sessionWorkingDirectories[sessionId] = undefined; // Set to undefined to clear
-        logger.debug(`Cleared working directory for HTTP session ${sessionId}`, { ...context, sessionId });
-      } else {
-        // Log warning instead of error, as clearing a non-existent/already cleared session isn't critical
-        logger.warning(`Attempted to clear working directory for unknown or already cleared HTTP session: ${sessionId}`, { ...context, sessionId });
-      }
-    } else if (TRANSPORT_TYPE === 'stdio') {
-      stdioWorkingDirectory = undefined; // Set to undefined to clear
-      logger.debug(`Cleared working directory for stdio session`, context);
-    }
-  };
-
-  const getWorkingDirectoryFn = (sessionId: string | undefined): string | undefined => {
-    if (TRANSPORT_TYPE === 'http') {
-      return sessionId ? sessionWorkingDirectories[sessionId] : undefined;
-    } else if (TRANSPORT_TYPE === 'stdio') {
-      return stdioWorkingDirectory;
-    }
-    return undefined; // Should not happen
-  };
-
-  const getSessionIdFn = (reqContext: Record<string, any>): string | undefined => {
-    // The SDK's callContext passed to the tool handler might contain session info.
-    // Alternatively, our RequestContext might have it if populated correctly.
-    // Let's assume it's available as 'sessionId' in the context passed to the tool handler.
-    // This might need refinement based on how the SDK passes context.
-    return reqContext?.sessionId as string | undefined;
-  };
-
-  // Initialize the state accessors for the tools that need them
-  initializeGitAddStateAccessors(getWorkingDirectoryFn, getSessionIdFn); // Initialize git_add accessors
-  initializeGitBranchStateAccessors(getWorkingDirectoryFn, getSessionIdFn); // Initialize git_branch accessors
-  initializeGitCheckoutStateAccessors(getWorkingDirectoryFn, getSessionIdFn); // Initialize git_checkout accessors
-  initializeGitCherryPickStateAccessors(getWorkingDirectoryFn, getSessionIdFn); // Initialize git_cherry_pick accessors
-  initializeGitCleanStateAccessors(getWorkingDirectoryFn, getSessionIdFn); // Initialize git_clean accessors
-  initializeGitClearWorkingDirStateAccessors(clearWorkingDirectoryFn, getSessionIdFn); // Initialize git_clear_working_dir accessors
-  // initializeGitCloneStateAccessors - No state needed for clone
-  initializeGitCommitStateAccessors(getWorkingDirectoryFn, getSessionIdFn); // Initialize git_commit accessors
-  initializeGitDiffStateAccessors(getWorkingDirectoryFn, getSessionIdFn); // Initialize git_diff accessors
-  initializeGitFetchStateAccessors(getWorkingDirectoryFn, getSessionIdFn); // Initialize git_fetch accessors
-  // initializeGitInitStateAccessors - No state needed for init
-  initializeGitLogStateAccessors(getWorkingDirectoryFn, getSessionIdFn); // Initialize git_log accessors
-  initializeGitMergeStateAccessors(getWorkingDirectoryFn, getSessionIdFn); // Initialize git_merge accessors
-  initializeGitPullStateAccessors(getWorkingDirectoryFn, getSessionIdFn); // Initialize git_pull accessors
-  initializeGitPushStateAccessors(getWorkingDirectoryFn, getSessionIdFn); // Initialize git_push accessors
-  initializeGitRebaseStateAccessors(getWorkingDirectoryFn, getSessionIdFn); // Initialize git_rebase accessors
-  initializeGitRemoteStateAccessors(getWorkingDirectoryFn, getSessionIdFn); // Initialize git_remote accessors
-  initializeGitResetStateAccessors(getWorkingDirectoryFn, getSessionIdFn); // Initialize git_reset accessors
-  initializeGitSetWorkingDirStateAccessors(setWorkingDirectoryFn, getSessionIdFn); // Initialize git_set_working_dir accessors
-  initializeGitShowStateAccessors(getWorkingDirectoryFn, getSessionIdFn); // Initialize git_show accessors
-  initializeGitStashStateAccessors(getWorkingDirectoryFn, getSessionIdFn); // Initialize git_stash accessors
-  initializeGitStatusStateAccessors(getWorkingDirectoryFn, getSessionIdFn); // Initialize git_status accessors
-  initializeGitTagStateAccessors(getWorkingDirectoryFn, getSessionIdFn); // Initialize git_tag accessors
-
   // --- HTTP Transport Setup ---
   if (TRANSPORT_TYPE === 'http') {
-    const app = express();
-    // Middleware to parse JSON request bodies.
-    app.use(express.json());
-
-    // Handle CORS preflight (OPTIONS) requests.
-    app.options(MCP_ENDPOINT_PATH, (req, res) => {
-      if (isOriginAllowed(req, res)) {
-        // Origin is allowed, send success status for preflight.
-        res.sendStatus(204); // No Content
-      } else {
-        // Origin not allowed, send forbidden status. isOriginAllowed logs the warning.
-        res.status(403).send('Forbidden: Invalid Origin');
-      }
-    });
-
-    // Middleware for all requests to check origin and set security headers.
-    app.use((req: Request, res: Response, next: NextFunction) => {
-      if (!isOriginAllowed(req, res)) {
-        // Origin not allowed, block the request. isOriginAllowed logs the warning.
-        res.status(403).send('Forbidden: Invalid Origin');
-        return; // Stop processing the request.
-      }
-      // Set standard security headers for allowed requests.
-      res.setHeader('X-Content-Type-Options', 'nosniff'); // Prevent MIME type sniffing.
-      // Consider adding other headers like Content-Security-Policy (CSP), Strict-Transport-Security (HSTS) here.
-      next(); // Origin is allowed, proceed to the specific route handler.
-    });
-
-
-    // Handle POST requests (Initialization and subsequent messages).
-    app.post(MCP_ENDPOINT_PATH, async (req, res) => {
-      // Extract session ID from the custom MCP header.
-      const sessionId = req.headers['mcp-session-id'] as string | undefined;
-      // Look up existing transport for this session.
-      let transport = sessionId ? httpTransports[sessionId] : undefined;
-      // Check if the request body is an MCP Initialize request.
-      const isInitReq = isInitializeRequest(req.body);
-      const requestId = (req.body as any)?.id || null; // For error responses
-
-      try {
-        // --- Handle Initialization Request ---
-        if (isInitReq) {
-          if (transport) {
-            // This indicates a potential client error or session ID collision (very unlikely).
-            logger.warning('Received initialize request on an existing session ID. Closing old session.', { ...context, sessionId });
-            // Close the old transport cleanly before creating a new one.
-            await transport.close(); // Assuming close is async and handles cleanup
-            delete httpTransports[sessionId!]; // Remove from map
-          }
-
-          logger.info('Initializing new session via POST request', { ...context, bodyPreview: JSON.stringify(req.body).substring(0, 100) }); // Log preview for debugging
-
-          // Create a new streamable HTTP transport for this session.
-          transport = new StreamableHTTPServerTransport({
-            sessionIdGenerator: () => randomUUID(), // Generate a unique session ID.
-            onsessioninitialized: (newId) => {
-              // Store the transport instance and initialize working directory state.
-              httpTransports[newId] = transport!;
-              sessionWorkingDirectories[newId] = undefined; // Initialize as undefined
-              logger.info(`HTTP Session created: ${newId}`, { ...context, sessionId: newId });
-            },
-          });
-
-          // Define cleanup logic when the transport closes (e.g., client disconnects, DELETE request).
-          transport.onclose = () => {
-            const closedSessionId = transport!.sessionId;
-            if (closedSessionId) {
-              delete httpTransports[closedSessionId];
-              delete sessionWorkingDirectories[closedSessionId]; // Clean up working directory state
-              logger.info(`HTTP Session closed: ${closedSessionId}`, { ...context, sessionId: closedSessionId });
-            }
-          };
-
-          // Create a dedicated McpServer instance for this new session.
-          const server = await createMcpServerInstance();
-          // Connect the server logic to the transport layer.
-          await server.connect(transport);
-          // Note: The transport handles sending the initialize response internally upon connection.
-          // We still need to call handleRequest below to process the *content* of the initialize message.
-
-        } else if (!transport) {
-          // --- Handle Non-Initialize Request without Valid Session ---
-          // If it's not an initialization request, but no transport was found for the session ID.
-          logger.warning('Invalid session ID provided for non-initialize POST request', { ...context, sessionId });
-          res.status(404).json({ jsonrpc: '2.0', error: { code: -32004, message: 'Invalid or expired session ID' }, id: requestId });
-          return; // Stop processing.
-        }
-
-        // --- Handle Request (Initialize or Subsequent Message) ---
-        // At this point, 'transport' must be defined (either found or newly created).
-        if (!transport) {
-           // Defensive check: This state should not be reachable if logic above is correct.
-           logger.error('Internal error: Transport is unexpectedly undefined before handleRequest', { ...context, sessionId, isInitReq });
-           throw new Error('Internal server error: Transport unavailable');
-        }
-        // Delegate the actual handling of the request (parsing, routing to server, sending response)
-        // to the transport instance. This works for both the initial initialize message and subsequent messages.
-        await transport.handleRequest(req, res, req.body);
-
-      } catch (err) {
-        // Catch-all for errors during POST handling.
-        logger.error('Error handling POST request', {
-            ...context,
-            sessionId,
-            isInitReq,
-            error: err instanceof Error ? err.message : String(err),
-            stack: err instanceof Error ? err.stack : undefined
-        });
-        // Send a generic JSON-RPC error response if headers haven't been sent yet.
-        if (!res.headersSent) {
-          res.status(500).json({ jsonrpc: '2.0', error: { code: -32603, message: 'Internal server error during POST handling' }, id: requestId });
-        }
-        // Ensure transport is cleaned up if an error occurred during initialization
-        if (isInitReq && transport && !transport.sessionId) {
-            // If init failed before session ID was assigned, manually trigger cleanup if needed
-            await transport.close().catch(closeErr => logger.error('Error closing transport after init failure', { ...context, closeError: closeErr }));
-        }
-      }
-    });
-
-    // Unified handler for GET (SSE connection) and DELETE (session termination).
-    const handleSessionReq = async (req: Request, res: Response) => {
-      const sessionId = req.headers['mcp-session-id'] as string | undefined;
-      const transport = sessionId ? httpTransports[sessionId] : undefined;
-      const method = req.method; // GET or DELETE
-
-      if (!transport) {
-        logger.warning(`Session not found for ${method} request`, { ...context, sessionId, method });
-        res.status(404).send('Session not found or expired');
-        return;
-      }
-
-      try {
-        // Delegate handling to the transport (establishes SSE for GET, triggers close for DELETE).
-        await transport.handleRequest(req, res);
-        logger.info(`Successfully handled ${method} request for session`, { ...context, sessionId, method });
-      } catch (err) {
-        logger.error(`Error handling ${method} request for session`, {
-            ...context,
-            sessionId,
-            method,
-            error: err instanceof Error ? err.message : String(err),
-            stack: err instanceof Error ? err.stack : undefined
-        });
-        // Send generic error if headers not sent (e.g., error before SSE connection established).
-        if (!res.headersSent) {
-            res.status(500).send('Internal Server Error');
-        }
-        // Note: If SSE connection was established, errors might need different handling (e.g., sending error event).
-        // The transport's handleRequest should manage SSE-specific error reporting.
-      }
-    };
-    // Route GET and DELETE requests to the unified handler.
-    app.get(MCP_ENDPOINT_PATH, handleSessionReq);
-    app.delete(MCP_ENDPOINT_PATH, handleSessionReq);
-
-    // --- Start HTTP Server ---
-    const serverInstance = http.createServer(app);
-    try {
-      // Attempt to start the server, retrying ports if necessary.
-      const actualPort = await startHttpServerWithRetry(serverInstance, HTTP_PORT, HTTP_HOST, MAX_PORT_RETRIES, context);
-      // Log the final address only after successful binding.
-      const serverAddress = `http://${HTTP_HOST}:${actualPort}${MCP_ENDPOINT_PATH}`;
-      // Use console.log for prominent startup message visibility.
-      console.log(`\n🚀 MCP Server running in HTTP mode at: ${serverAddress}\n`);
-    } catch (err) {
-      // If startHttpServerWithRetry failed after all retries.
-      logger.fatal('HTTP server failed to start after multiple port retries.', { ...context, error: err instanceof Error ? err.message : String(err) });
-      // Rethrow or exit, as the server cannot run.
-      throw err;
-    }
-    // For HTTP transport, the server runs indefinitely, so return void.
-    return;
+    // Delegate to the HTTP transport setup function.
+    // Pass the server instance factory function.
+    // Capture and return the http.Server instance.
+    const httpServer = await startHttpTransport(createMcpServerInstance, context);
+    return httpServer;
   }
 
   // --- Stdio Transport Setup ---
   if (TRANSPORT_TYPE === 'stdio') {
-    // stdioWorkingDirectory is declared above the state accessor functions
-
-    try {
-      // Create a single server instance for the stdio process.
-      // State accessors are already initialized above.
-      const server = await createMcpServerInstance();
-      // Create the stdio transport, which reads from stdin and writes to stdout.
-      const transport = new StdioServerTransport();
-      // Connect the server logic to the stdio transport.
-      await server.connect(transport);
-      logger.info('MCP Server connected via stdio transport', context);
-      // Return the server instance, as it might be needed by the calling process.
-      return server;
-    } catch (err) {
-      // Handle critical errors during stdio setup.
-      ErrorHandler.handleError(err, { operation: 'stdioConnect', critical: true });
-      // Rethrow to indicate failure.
-      throw err;
-    }
+    // Create a single server instance for the stdio process.
+    const server = await createMcpServerInstance();
+    // Delegate connection to the Stdio transport function.
+    await connectStdioTransport(server, context);
+    // Return the server instance, as it might be needed by the calling process.
+    return server;
   }
 
   // --- Unsupported Transport ---
@@ -600,9 +165,9 @@ async function startTransport(): Promise<McpServer | void> {
  *
  * @async
  * @export
- * @returns {Promise<void | McpServer>} Resolves with the McpServer instance if using stdio, or void if using http (as it runs indefinitely). Rejects on critical startup failure.
+ * @returns {Promise<McpServer | http.Server>} Resolves with the McpServer instance if using stdio, or the http.Server instance if using http. Rejects on critical startup failure.
  */
-export async function initializeAndStartServer(): Promise<void | McpServer> {
+export async function initializeAndStartServer(): Promise<McpServer | http.Server> {
   try {
     // Start the appropriate transport (stdio or http).
     return await startTransport();
diff --git a/src/mcp-server/tools/gitAdd/logic.ts b/src/mcp-server/tools/gitAdd/logic.ts
index 6cb21ec..ab24c7a 100644
--- a/src/mcp-server/tools/gitAdd/logic.ts
+++ b/src/mcp-server/tools/gitAdd/logic.ts
@@ -1,11 +1,13 @@
-import { z } from 'zod';
-import { promisify } from 'util';
 import { exec } from 'child_process';
-import { logger } from '../../../utils/logger.js';
-import { RequestContext } from '../../../utils/requestContext.js';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js';
-import { sanitization } from '../../../utils/sanitization.js';
-import path from 'path'; // Import path module
+import { promisify } from 'util';
+import { z } from 'zod';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (RequestContext from ../utils/internal/requestContext.js)
+import { BaseErrorCode, McpError } from '../../../types-global/errors.js'; // Keep direct import for types-global
+import { RequestContext } from '../../../utils/index.js';
+// Import utils from barrel (sanitization from ../utils/security/sanitization.js)
+import { sanitization } from '../../../utils/index.js';
 
 const execAsync = promisify(exec);
 
diff --git a/src/mcp-server/tools/gitAdd/registration.ts b/src/mcp-server/tools/gitAdd/registration.ts
index 419fce1..258e18a 100644
--- a/src/mcp-server/tools/gitAdd/registration.ts
+++ b/src/mcp-server/tools/gitAdd/registration.ts
@@ -1,11 +1,14 @@
 import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
 import { CallToolResult, TextContent } from '@modelcontextprotocol/sdk/types.js';
-import { logger } from '../../../utils/logger.js';
-import { ErrorHandler } from '../../../utils/errorHandler.js';
-import { requestContextService } from '../../../utils/requestContext.js';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (ErrorHandler from ../utils/internal/errorHandler.js)
+import { ErrorHandler } from '../../../utils/index.js';
+// Import utils from barrel (requestContextService from ../utils/internal/requestContext.js)
+import { requestContextService } from '../../../utils/index.js';
 // Import the result type along with the function and input schema
-import { addGitFiles, GitAddInputSchema, GitAddInput, GitAddResult } from './logic.js';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js'; // Import BaseErrorCode
+import { BaseErrorCode } from '../../../types-global/errors.js'; // Import BaseErrorCode
+import { addGitFiles, GitAddInput, GitAddInputSchema, GitAddResult } from './logic.js';
 
 // --- State Accessors ---
 /** Type definition for the function that gets the working directory for a session */
diff --git a/src/mcp-server/tools/gitBranch/logic.ts b/src/mcp-server/tools/gitBranch/logic.ts
index 8577406..6878272 100644
--- a/src/mcp-server/tools/gitBranch/logic.ts
+++ b/src/mcp-server/tools/gitBranch/logic.ts
@@ -1,10 +1,13 @@
-import { z } from 'zod';
-import { promisify } from 'util';
 import { exec } from 'child_process';
-import { logger } from '../../../utils/logger.js';
-import { RequestContext } from '../../../utils/requestContext.js';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js';
-import { sanitization } from '../../../utils/sanitization.js';
+import { promisify } from 'util';
+import { z } from 'zod';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (RequestContext from ../utils/internal/requestContext.js)
+import { BaseErrorCode, McpError } from '../../../types-global/errors.js'; // Keep direct import for types-global
+import { RequestContext } from '../../../utils/index.js';
+// Import utils from barrel (sanitization from ../utils/security/sanitization.js)
+import { sanitization } from '../../../utils/index.js';
 
 const execAsync = promisify(exec);
 
diff --git a/src/mcp-server/tools/gitBranch/registration.ts b/src/mcp-server/tools/gitBranch/registration.ts
index eedd258..c58f906 100644
--- a/src/mcp-server/tools/gitBranch/registration.ts
+++ b/src/mcp-server/tools/gitBranch/registration.ts
@@ -1,10 +1,13 @@
 import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
 import { CallToolResult, TextContent } from '@modelcontextprotocol/sdk/types.js';
-import { logger } from '../../../utils/logger.js';
-import { ErrorHandler } from '../../../utils/errorHandler.js';
-import { requestContextService } from '../../../utils/requestContext.js';
-import { gitBranchLogic, GitBranchInputSchema, GitBranchInput, GitBranchResult, GitBranchBaseSchema } from './logic.js';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (ErrorHandler from ../utils/internal/errorHandler.js)
+import { ErrorHandler } from '../../../utils/index.js';
+// Import utils from barrel (requestContextService from ../utils/internal/requestContext.js)
+import { BaseErrorCode } from '../../../types-global/errors.js'; // Keep direct import for types-global
+import { requestContextService } from '../../../utils/index.js';
+import { GitBranchBaseSchema, GitBranchInput, gitBranchLogic, GitBranchResult } from './logic.js';
 
 // --- State Accessors ---
 export type GetWorkingDirectoryFn = (sessionId: string | undefined) => string | undefined;
diff --git a/src/mcp-server/tools/gitCheckout/logic.ts b/src/mcp-server/tools/gitCheckout/logic.ts
index cca3815..1a89f5a 100644
--- a/src/mcp-server/tools/gitCheckout/logic.ts
+++ b/src/mcp-server/tools/gitCheckout/logic.ts
@@ -1,10 +1,13 @@
-import { z } from 'zod';
-import { promisify } from 'util';
 import { exec } from 'child_process';
-import { logger } from '../../../utils/logger.js';
-import { RequestContext } from '../../../utils/requestContext.js';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js';
-import { sanitization } from '../../../utils/sanitization.js';
+import { promisify } from 'util';
+import { z } from 'zod';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (RequestContext from ../utils/internal/requestContext.js)
+import { BaseErrorCode, McpError } from '../../../types-global/errors.js'; // Keep direct import for types-global
+import { RequestContext } from '../../../utils/index.js';
+// Import utils from barrel (sanitization from ../utils/security/sanitization.js)
+import { sanitization } from '../../../utils/index.js';
 
 const execAsync = promisify(exec);
 
diff --git a/src/mcp-server/tools/gitCheckout/registration.ts b/src/mcp-server/tools/gitCheckout/registration.ts
index 4cbb5f2..5779d3e 100644
--- a/src/mcp-server/tools/gitCheckout/registration.ts
+++ b/src/mcp-server/tools/gitCheckout/registration.ts
@@ -1,11 +1,13 @@
 import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
 import { CallToolResult, TextContent } from '@modelcontextprotocol/sdk/types.js';
-import { z } from 'zod';
-import { ErrorHandler } from '../../../utils/errorHandler.js';
-import { logger } from '../../../utils/logger.js';
-import { requestContextService, RequestContext } from '../../../utils/requestContext.js';
-import { GitCheckoutInputSchema, checkoutGit, GitCheckoutInput, GitCheckoutResult } from './logic.js';
-import { BaseErrorCode, McpError } from '../../../types-global/errors.js';
+// Import utils from barrel (ErrorHandler from ../utils/internal/errorHandler.js)
+import { ErrorHandler } from '../../../utils/index.js';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (requestContextService, RequestContext from ../utils/internal/requestContext.js)
+import { BaseErrorCode } from '../../../types-global/errors.js'; // Keep direct import for types-global
+import { requestContextService } from '../../../utils/index.js';
+import { checkoutGit, GitCheckoutInput, GitCheckoutInputSchema, GitCheckoutResult } from './logic.js';
 
 // --- State Accessors ---
 // These functions need to be provided by the server setup layer (server.ts)
diff --git a/src/mcp-server/tools/gitCherryPick/logic.ts b/src/mcp-server/tools/gitCherryPick/logic.ts
index eba245f..ad3876a 100644
--- a/src/mcp-server/tools/gitCherryPick/logic.ts
+++ b/src/mcp-server/tools/gitCherryPick/logic.ts
@@ -1,10 +1,13 @@
-import { z } from 'zod';
-import { promisify } from 'util';
 import { exec } from 'child_process';
-import { logger } from '../../../utils/logger.js';
-import { RequestContext } from '../../../utils/requestContext.js';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js';
-import { sanitization } from '../../../utils/sanitization.js';
+import { promisify } from 'util';
+import { z } from 'zod';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (RequestContext from ../utils/internal/requestContext.js)
+import { BaseErrorCode, McpError } from '../../../types-global/errors.js'; // Keep direct import for types-global
+import { RequestContext } from '../../../utils/index.js';
+// Import utils from barrel (sanitization from ../utils/security/sanitization.js)
+import { sanitization } from '../../../utils/index.js';
 
 const execAsync = promisify(exec);
 
diff --git a/src/mcp-server/tools/gitCherryPick/registration.ts b/src/mcp-server/tools/gitCherryPick/registration.ts
index 7678420..2b464c7 100644
--- a/src/mcp-server/tools/gitCherryPick/registration.ts
+++ b/src/mcp-server/tools/gitCherryPick/registration.ts
@@ -1,10 +1,13 @@
 import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
 import { CallToolResult, TextContent } from '@modelcontextprotocol/sdk/types.js';
-import { logger } from '../../../utils/logger.js';
-import { ErrorHandler } from '../../../utils/errorHandler.js';
-import { requestContextService } from '../../../utils/requestContext.js';
-import { gitCherryPickLogic, GitCherryPickInputSchema, GitCherryPickInput, GitCherryPickResult } from './logic.js';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (ErrorHandler from ../utils/internal/errorHandler.js)
+import { ErrorHandler } from '../../../utils/index.js';
+// Import utils from barrel (requestContextService from ../utils/internal/requestContext.js)
+import { BaseErrorCode } from '../../../types-global/errors.js'; // Keep direct import for types-global
+import { requestContextService } from '../../../utils/index.js';
+import { GitCherryPickInput, GitCherryPickInputSchema, gitCherryPickLogic, GitCherryPickResult } from './logic.js';
 
 // --- State Accessors ---
 export type GetWorkingDirectoryFn = (sessionId: string | undefined) => string | undefined;
diff --git a/src/mcp-server/tools/gitClean/logic.ts b/src/mcp-server/tools/gitClean/logic.ts
index 83728c0..6d038d4 100644
--- a/src/mcp-server/tools/gitClean/logic.ts
+++ b/src/mcp-server/tools/gitClean/logic.ts
@@ -1,10 +1,13 @@
-import { z } from 'zod';
-import { promisify } from 'util';
 import { exec } from 'child_process';
-import { logger } from '../../../utils/logger.js';
-import { RequestContext } from '../../../utils/requestContext.js';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js';
-import { sanitization } from '../../../utils/sanitization.js';
+import { promisify } from 'util';
+import { z } from 'zod';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (RequestContext from ../utils/internal/requestContext.js)
+import { BaseErrorCode, McpError } from '../../../types-global/errors.js'; // Keep direct import for types-global
+import { RequestContext } from '../../../utils/index.js';
+// Import utils from barrel (sanitization from ../utils/security/sanitization.js)
+import { sanitization } from '../../../utils/index.js';
 
 const execAsync = promisify(exec);
 
diff --git a/src/mcp-server/tools/gitClean/registration.ts b/src/mcp-server/tools/gitClean/registration.ts
index fff7830..105d2de 100644
--- a/src/mcp-server/tools/gitClean/registration.ts
+++ b/src/mcp-server/tools/gitClean/registration.ts
@@ -1,11 +1,14 @@
 import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
 import { CallToolResult, TextContent } from '@modelcontextprotocol/sdk/types.js';
-import { logger } from '../../../utils/logger.js';
-import { ErrorHandler } from '../../../utils/errorHandler.js';
-import { requestContextService } from '../../../utils/requestContext.js';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (ErrorHandler from ../utils/internal/errorHandler.js)
+import { ErrorHandler } from '../../../utils/index.js';
+// Import utils from barrel (requestContextService from ../utils/internal/requestContext.js)
+import { requestContextService } from '../../../utils/index.js';
 // Import the schema and types
-import { gitCleanLogic, GitCleanInputSchema, GitCleanInput, GitCleanResult } from './logic.js';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js';
+import { BaseErrorCode } from '../../../types-global/errors.js'; // Keep direct import for types-global
+import { GitCleanInput, GitCleanInputSchema, gitCleanLogic, GitCleanResult } from './logic.js';
 
 // --- State Accessors ---
 /** Type definition for the function that gets the working directory for a session */
diff --git a/src/mcp-server/tools/gitClearWorkingDir/logic.ts b/src/mcp-server/tools/gitClearWorkingDir/logic.ts
index b470181..ba43a8e 100644
--- a/src/mcp-server/tools/gitClearWorkingDir/logic.ts
+++ b/src/mcp-server/tools/gitClearWorkingDir/logic.ts
@@ -1,7 +1,9 @@
 import { z } from 'zod';
-import { RequestContext } from '../../../utils/requestContext.js';
-import { logger } from '../../../utils/logger.js';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js';
+// Import utils from barrel (RequestContext from ../utils/internal/requestContext.js)
+import { RequestContext } from '../../../utils/index.js';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { BaseErrorCode, McpError } from '../../../types-global/errors.js'; // Keep direct import for types-global
+import { logger } from '../../../utils/index.js';
 
 // Define the Zod schema for input validation (no arguments needed)
 export const GitClearWorkingDirInputSchema = z.object({});
diff --git a/src/mcp-server/tools/gitClearWorkingDir/registration.ts b/src/mcp-server/tools/gitClearWorkingDir/registration.ts
index 1b616e7..2e967dd 100644
--- a/src/mcp-server/tools/gitClearWorkingDir/registration.ts
+++ b/src/mcp-server/tools/gitClearWorkingDir/registration.ts
@@ -1,11 +1,13 @@
 import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
 import { CallToolResult, TextContent } from '@modelcontextprotocol/sdk/types.js';
-import { z } from 'zod';
-import { ErrorHandler } from '../../../utils/errorHandler.js';
-import { logger } from '../../../utils/logger.js';
-import { requestContextService, RequestContext } from '../../../utils/requestContext.js';
-import { GitClearWorkingDirInputSchema, gitClearWorkingDirLogic, GitClearWorkingDirInput } from './logic.js';
-import { BaseErrorCode, McpError } from '../../../types-global/errors.js';
+// Import utils from barrel (ErrorHandler from ../utils/internal/errorHandler.js)
+import { ErrorHandler } from '../../../utils/index.js';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (requestContextService, RequestContext from ../utils/internal/requestContext.js)
+import { BaseErrorCode } from '../../../types-global/errors.js'; // Keep direct import for types-global
+import { requestContextService } from '../../../utils/index.js';
+import { GitClearWorkingDirInput, GitClearWorkingDirInputSchema, gitClearWorkingDirLogic } from './logic.js';
 
 // --- State Accessors ---
 
diff --git a/src/mcp-server/tools/gitClone/logic.ts b/src/mcp-server/tools/gitClone/logic.ts
index 9385311..5b2dbbd 100644
--- a/src/mcp-server/tools/gitClone/logic.ts
+++ b/src/mcp-server/tools/gitClone/logic.ts
@@ -1,12 +1,14 @@
-import { z } from 'zod';
-import { promisify } from 'util';
 import { exec } from 'child_process';
 import fs from 'fs/promises';
-import path from 'path';
-import { logger } from '../../../utils/logger.js';
-import { RequestContext } from '../../../utils/requestContext.js';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js';
-import { sanitization } from '../../../utils/sanitization.js';
+import { promisify } from 'util';
+import { z } from 'zod';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (RequestContext from ../utils/internal/requestContext.js)
+import { BaseErrorCode, McpError } from '../../../types-global/errors.js'; // Keep direct import for types-global
+import { RequestContext } from '../../../utils/index.js';
+// Import utils from barrel (sanitization from ../utils/security/sanitization.js)
+import { sanitization } from '../../../utils/index.js';
 
 const execAsync = promisify(exec);
 
diff --git a/src/mcp-server/tools/gitClone/registration.ts b/src/mcp-server/tools/gitClone/registration.ts
index f250dd5..b249c03 100644
--- a/src/mcp-server/tools/gitClone/registration.ts
+++ b/src/mcp-server/tools/gitClone/registration.ts
@@ -1,10 +1,13 @@
 import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
 import { CallToolResult, TextContent } from '@modelcontextprotocol/sdk/types.js';
-import { ErrorHandler } from '../../../utils/errorHandler.js';
-import { logger } from '../../../utils/logger.js';
-import { requestContextService } from '../../../utils/requestContext.js';
+// Import utils from barrel (ErrorHandler from ../utils/internal/errorHandler.js)
+import { ErrorHandler } from '../../../utils/index.js';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (requestContextService from ../utils/internal/requestContext.js)
+import { requestContextService } from '../../../utils/index.js';
 import { GitCloneInputSchema, gitCloneLogic, GitCloneInput, GitCloneResult } from './logic.js';
-import { BaseErrorCode } from '../../../types-global/errors.js';
+import { BaseErrorCode } from '../../../types-global/errors.js'; // Keep direct import for types-global
 
 const TOOL_NAME = 'git_clone';
 const TOOL_DESCRIPTION = 'Clones a Git repository from a given URL into a specified absolute directory path. Supports cloning specific branches and setting clone depth.';
diff --git a/src/mcp-server/tools/gitCommit/logic.ts b/src/mcp-server/tools/gitCommit/logic.ts
index dce993d..9d529f4 100644
--- a/src/mcp-server/tools/gitCommit/logic.ts
+++ b/src/mcp-server/tools/gitCommit/logic.ts
@@ -1,10 +1,13 @@
 import { exec } from 'child_process';
 import { promisify } from 'util';
 import { z } from 'zod';
-import { BaseErrorCode, McpError } from '../../../types-global/errors.js';
-import { logger } from '../../../utils/logger.js';
-import { RequestContext } from '../../../utils/requestContext.js';
-import { sanitization } from '../../../utils/sanitization.js';
+import { BaseErrorCode, McpError } from '../../../types-global/errors.js'; // Keep direct import for types-global
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (RequestContext from ../utils/internal/requestContext.js)
+import { RequestContext } from '../../../utils/index.js';
+// Import utils from barrel (sanitization from ../utils/security/sanitization.js)
+import { sanitization } from '../../../utils/index.js';
 
 const execAsync = promisify(exec);
 
diff --git a/src/mcp-server/tools/gitCommit/registration.ts b/src/mcp-server/tools/gitCommit/registration.ts
index f8345bc..7407dbb 100644
--- a/src/mcp-server/tools/gitCommit/registration.ts
+++ b/src/mcp-server/tools/gitCommit/registration.ts
@@ -1,10 +1,13 @@
 import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
 import { CallToolResult, TextContent } from '@modelcontextprotocol/sdk/types.js';
-import { ErrorHandler } from '../../../utils/errorHandler.js';
-import { logger } from '../../../utils/logger.js';
-import { requestContextService } from '../../../utils/requestContext.js';
+// Import utils from barrel (ErrorHandler from ../utils/internal/errorHandler.js)
+import { ErrorHandler } from '../../../utils/index.js';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (requestContextService from ../utils/internal/requestContext.js)
+import { requestContextService } from '../../../utils/index.js';
 // Import the result type along with the function and input schema
-import { BaseErrorCode } from '../../../types-global/errors.js'; // Import BaseErrorCode
+import { BaseErrorCode } from '../../../types-global/errors.js'; // Keep direct import for types-global
 import { commitGitChanges, GitCommitInput, GitCommitInputSchema, GitCommitResult } from './logic.js';
 
 // --- State Accessors ---
diff --git a/src/mcp-server/tools/gitDiff/logic.ts b/src/mcp-server/tools/gitDiff/logic.ts
index ad810f0..7b36a30 100644
--- a/src/mcp-server/tools/gitDiff/logic.ts
+++ b/src/mcp-server/tools/gitDiff/logic.ts
@@ -1,10 +1,13 @@
-import { z } from 'zod';
-import { promisify } from 'util';
 import { exec } from 'child_process';
-import { logger } from '../../../utils/logger.js';
-import { RequestContext } from '../../../utils/requestContext.js';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js';
-import { sanitization } from '../../../utils/sanitization.js';
+import { promisify } from 'util';
+import { z } from 'zod';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (RequestContext from ../utils/internal/requestContext.js)
+import { BaseErrorCode, McpError } from '../../../types-global/errors.js'; // Keep direct import for types-global
+import { RequestContext } from '../../../utils/index.js';
+// Import utils from barrel (sanitization from ../utils/security/sanitization.js)
+import { sanitization } from '../../../utils/index.js';
 
 const execAsync = promisify(exec);
 
diff --git a/src/mcp-server/tools/gitDiff/registration.ts b/src/mcp-server/tools/gitDiff/registration.ts
index eb510a5..6ffdedb 100644
--- a/src/mcp-server/tools/gitDiff/registration.ts
+++ b/src/mcp-server/tools/gitDiff/registration.ts
@@ -1,12 +1,14 @@
 import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
 import { CallToolResult, TextContent } from '@modelcontextprotocol/sdk/types.js';
-import { z } from 'zod';
-import { ErrorHandler } from '../../../utils/errorHandler.js';
-import { logger } from '../../../utils/logger.js';
-import { requestContextService, RequestContext } from '../../../utils/requestContext.js';
+// Import utils from barrel (ErrorHandler from ../utils/internal/errorHandler.js)
+import { ErrorHandler } from '../../../utils/index.js';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (requestContextService, RequestContext from ../utils/internal/requestContext.js)
+import { requestContextService } from '../../../utils/index.js';
 // Import the shape and the final schema/types
-import { GitDiffInputShape, GitDiffInputSchema, diffGitChanges, GitDiffInput, GitDiffResult } from './logic.js';
-import { BaseErrorCode, McpError } from '../../../types-global/errors.js';
+import { BaseErrorCode } from '../../../types-global/errors.js'; // Keep direct import for types-global
+import { diffGitChanges, GitDiffInput, GitDiffInputShape, GitDiffResult } from './logic.js';
 
 // --- State Accessors ---
 // These functions need to be provided by the server setup layer (server.ts)
diff --git a/src/mcp-server/tools/gitFetch/logic.ts b/src/mcp-server/tools/gitFetch/logic.ts
index 7327a4b..44042cf 100644
--- a/src/mcp-server/tools/gitFetch/logic.ts
+++ b/src/mcp-server/tools/gitFetch/logic.ts
@@ -1,10 +1,13 @@
-import { z } from 'zod';
-import { promisify } from 'util';
 import { exec } from 'child_process';
-import { logger } from '../../../utils/logger.js';
-import { RequestContext } from '../../../utils/requestContext.js';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js';
-import { sanitization } from '../../../utils/sanitization.js';
+import { promisify } from 'util';
+import { z } from 'zod';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (RequestContext from ../utils/internal/requestContext.js)
+import { BaseErrorCode, McpError } from '../../../types-global/errors.js'; // Keep direct import for types-global
+import { RequestContext } from '../../../utils/index.js';
+// Import utils from barrel (sanitization from ../utils/security/sanitization.js)
+import { sanitization } from '../../../utils/index.js';
 
 const execAsync = promisify(exec);
 
diff --git a/src/mcp-server/tools/gitFetch/registration.ts b/src/mcp-server/tools/gitFetch/registration.ts
index 4f57e65..385ec4f 100644
--- a/src/mcp-server/tools/gitFetch/registration.ts
+++ b/src/mcp-server/tools/gitFetch/registration.ts
@@ -1,11 +1,13 @@
 import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
 import { CallToolResult, TextContent } from '@modelcontextprotocol/sdk/types.js';
-import { z } from 'zod';
-import { ErrorHandler } from '../../../utils/errorHandler.js';
-import { logger } from '../../../utils/logger.js';
-import { requestContextService, RequestContext } from '../../../utils/requestContext.js';
-import { GitFetchInputSchema, fetchGitRemote, GitFetchInput, GitFetchResult } from './logic.js';
-import { BaseErrorCode, McpError } from '../../../types-global/errors.js';
+// Import utils from barrel (ErrorHandler from ../utils/internal/errorHandler.js)
+import { ErrorHandler } from '../../../utils/index.js';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (requestContextService, RequestContext from ../utils/internal/requestContext.js)
+import { BaseErrorCode } from '../../../types-global/errors.js'; // Keep direct import for types-global
+import { requestContextService } from '../../../utils/index.js';
+import { fetchGitRemote, GitFetchInput, GitFetchInputSchema, GitFetchResult } from './logic.js';
 
 // --- State Accessors ---
 // These functions need to be provided by the server setup layer (server.ts)
diff --git a/src/mcp-server/tools/gitInit/logic.ts b/src/mcp-server/tools/gitInit/logic.ts
index 272cb71..1678050 100644
--- a/src/mcp-server/tools/gitInit/logic.ts
+++ b/src/mcp-server/tools/gitInit/logic.ts
@@ -1,12 +1,15 @@
-import { z } from 'zod';
-import { promisify } from 'util';
 import { exec } from 'child_process';
 import fs from 'fs/promises';
 import path from 'path';
-import { logger } from '../../../utils/logger.js';
-import { RequestContext } from '../../../utils/requestContext.js';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js';
-import { sanitization } from '../../../utils/sanitization.js';
+import { promisify } from 'util';
+import { z } from 'zod';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (RequestContext from ../utils/internal/requestContext.js)
+import { BaseErrorCode, McpError } from '../../../types-global/errors.js'; // Keep direct import for types-global
+import { RequestContext } from '../../../utils/index.js';
+// Import utils from barrel (sanitization from ../utils/security/sanitization.js)
+import { sanitization } from '../../../utils/index.js';
 
 const execAsync = promisify(exec);
 
diff --git a/src/mcp-server/tools/gitInit/registration.ts b/src/mcp-server/tools/gitInit/registration.ts
index aeef714..e29ccab 100644
--- a/src/mcp-server/tools/gitInit/registration.ts
+++ b/src/mcp-server/tools/gitInit/registration.ts
@@ -1,10 +1,13 @@
 import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
 import { CallToolResult, TextContent } from '@modelcontextprotocol/sdk/types.js';
-import { ErrorHandler } from '../../../utils/errorHandler.js';
-import { logger } from '../../../utils/logger.js';
-import { requestContextService } from '../../../utils/requestContext.js';
-import { GitInitInputSchema, gitInitLogic, GitInitInput, GitInitResult } from './logic.js';
-import { BaseErrorCode } from '../../../types-global/errors.js';
+// Import utils from barrel (ErrorHandler from ../utils/internal/errorHandler.js)
+import { ErrorHandler } from '../../../utils/index.js';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (requestContextService from ../utils/internal/requestContext.js)
+import { BaseErrorCode } from '../../../types-global/errors.js'; // Keep direct import for types-global
+import { requestContextService } from '../../../utils/index.js';
+import { GitInitInput, GitInitInputSchema, gitInitLogic, GitInitResult } from './logic.js';
 
 const TOOL_NAME = 'git_init';
 const TOOL_DESCRIPTION = 'Initializes a new Git repository at the specified absolute path. Can optionally set the initial branch name and create a bare repository.';
diff --git a/src/mcp-server/tools/gitLog/logic.ts b/src/mcp-server/tools/gitLog/logic.ts
index c4da218..d2f5729 100644
--- a/src/mcp-server/tools/gitLog/logic.ts
+++ b/src/mcp-server/tools/gitLog/logic.ts
@@ -1,10 +1,13 @@
-import { z } from 'zod';
-import { promisify } from 'util';
 import { exec } from 'child_process';
-import { logger } from '../../../utils/logger.js';
-import { RequestContext } from '../../../utils/requestContext.js';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js';
-import { sanitization } from '../../../utils/sanitization.js';
+import { promisify } from 'util';
+import { z } from 'zod';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (RequestContext from ../utils/internal/requestContext.js)
+import { BaseErrorCode, McpError } from '../../../types-global/errors.js'; // Keep direct import for types-global
+import { RequestContext } from '../../../utils/index.js';
+// Import utils from barrel (sanitization from ../utils/security/sanitization.js)
+import { sanitization } from '../../../utils/index.js';
 
 const execAsync = promisify(exec);
 
diff --git a/src/mcp-server/tools/gitLog/registration.ts b/src/mcp-server/tools/gitLog/registration.ts
index a6aa16f..7022498 100644
--- a/src/mcp-server/tools/gitLog/registration.ts
+++ b/src/mcp-server/tools/gitLog/registration.ts
@@ -1,11 +1,13 @@
 import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
 import { CallToolResult, TextContent } from '@modelcontextprotocol/sdk/types.js';
-import { z } from 'zod';
-import { ErrorHandler } from '../../../utils/errorHandler.js';
-import { logger } from '../../../utils/logger.js';
-import { requestContextService, RequestContext } from '../../../utils/requestContext.js';
-import { GitLogInputSchema, logGitHistory, GitLogInput, GitLogResult } from './logic.js';
-import { BaseErrorCode, McpError } from '../../../types-global/errors.js';
+// Import utils from barrel (ErrorHandler from ../utils/internal/errorHandler.js)
+import { ErrorHandler } from '../../../utils/index.js';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (requestContextService, RequestContext from ../utils/internal/requestContext.js)
+import { BaseErrorCode } from '../../../types-global/errors.js'; // Keep direct import for types-global
+import { requestContextService } from '../../../utils/index.js';
+import { GitLogInput, GitLogInputSchema, GitLogResult, logGitHistory } from './logic.js';
 
 // --- State Accessors ---
 // These functions need to be provided by the server setup layer (server.ts)
diff --git a/src/mcp-server/tools/gitMerge/logic.ts b/src/mcp-server/tools/gitMerge/logic.ts
index 6efd7db..89b8c9d 100644
--- a/src/mcp-server/tools/gitMerge/logic.ts
+++ b/src/mcp-server/tools/gitMerge/logic.ts
@@ -1,10 +1,13 @@
 import { z } from 'zod';
 import { promisify } from 'util';
 import { exec } from 'child_process';
-import { logger } from '../../../utils/logger.js';
-import { RequestContext } from '../../../utils/requestContext.js';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js';
-import { sanitization } from '../../../utils/sanitization.js';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (RequestContext from ../utils/internal/requestContext.js)
+import { RequestContext } from '../../../utils/index.js';
+import { McpError, BaseErrorCode } from '../../../types-global/errors.js'; // Keep direct import for types-global
+// Import utils from barrel (sanitization from ../utils/security/sanitization.js)
+import { sanitization } from '../../../utils/index.js';
 import path from 'path'; // Import path module
 
 const execAsync = promisify(exec);
diff --git a/src/mcp-server/tools/gitMerge/registration.ts b/src/mcp-server/tools/gitMerge/registration.ts
index b9a1c0f..3d639da 100644
--- a/src/mcp-server/tools/gitMerge/registration.ts
+++ b/src/mcp-server/tools/gitMerge/registration.ts
@@ -1,10 +1,13 @@
 import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
 import { CallToolResult, TextContent } from '@modelcontextprotocol/sdk/types.js';
-import { logger } from '../../../utils/logger.js';
-import { ErrorHandler } from '../../../utils/errorHandler.js';
-import { requestContextService } from '../../../utils/requestContext.js';
-import { gitMergeLogic, GitMergeInputSchema, GitMergeInput, GitMergeResult } from './logic.js';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (ErrorHandler from ../utils/internal/errorHandler.js)
+import { ErrorHandler } from '../../../utils/index.js';
+// Import utils from barrel (requestContextService from ../utils/internal/requestContext.js)
+import { BaseErrorCode } from '../../../types-global/errors.js'; // Keep direct import for types-global
+import { requestContextService } from '../../../utils/index.js';
+import { GitMergeInput, GitMergeInputSchema, gitMergeLogic, GitMergeResult } from './logic.js';
 
 // --- State Accessors ---
 // Copied from gitCommit/registration.ts as they are likely needed here too
diff --git a/src/mcp-server/tools/gitPull/logic.ts b/src/mcp-server/tools/gitPull/logic.ts
index 6325fb3..85e57bd 100644
--- a/src/mcp-server/tools/gitPull/logic.ts
+++ b/src/mcp-server/tools/gitPull/logic.ts
@@ -1,10 +1,13 @@
-import { z } from 'zod';
-import { promisify } from 'util';
 import { exec } from 'child_process';
-import { logger } from '../../../utils/logger.js';
-import { RequestContext } from '../../../utils/requestContext.js';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js';
-import { sanitization } from '../../../utils/sanitization.js';
+import { promisify } from 'util';
+import { z } from 'zod';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (RequestContext from ../utils/internal/requestContext.js)
+import { BaseErrorCode, McpError } from '../../../types-global/errors.js'; // Keep direct import for types-global
+import { RequestContext } from '../../../utils/index.js';
+// Import utils from barrel (sanitization from ../utils/security/sanitization.js)
+import { sanitization } from '../../../utils/index.js';
 
 const execAsync = promisify(exec);
 
diff --git a/src/mcp-server/tools/gitPull/registration.ts b/src/mcp-server/tools/gitPull/registration.ts
index 2cb0370..a0378ac 100644
--- a/src/mcp-server/tools/gitPull/registration.ts
+++ b/src/mcp-server/tools/gitPull/registration.ts
@@ -1,11 +1,13 @@
 import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
 import { CallToolResult, TextContent } from '@modelcontextprotocol/sdk/types.js';
-import { z } from 'zod';
-import { ErrorHandler } from '../../../utils/errorHandler.js';
-import { logger } from '../../../utils/logger.js';
-import { requestContextService, RequestContext } from '../../../utils/requestContext.js';
-import { GitPullInputSchema, pullGitChanges, GitPullInput, GitPullResult } from './logic.js';
-import { BaseErrorCode, McpError } from '../../../types-global/errors.js';
+// Import utils from barrel (ErrorHandler from ../utils/internal/errorHandler.js)
+import { ErrorHandler } from '../../../utils/index.js';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (requestContextService, RequestContext from ../utils/internal/requestContext.js)
+import { BaseErrorCode } from '../../../types-global/errors.js'; // Keep direct import for types-global
+import { requestContextService } from '../../../utils/index.js';
+import { GitPullInput, GitPullInputSchema, GitPullResult, pullGitChanges } from './logic.js';
 
 // --- State Accessors ---
 // These functions need to be provided by the server setup layer (server.ts)
diff --git a/src/mcp-server/tools/gitPush/logic.ts b/src/mcp-server/tools/gitPush/logic.ts
index ef4a569..c2e636b 100644
--- a/src/mcp-server/tools/gitPush/logic.ts
+++ b/src/mcp-server/tools/gitPush/logic.ts
@@ -1,10 +1,13 @@
-import { z } from 'zod';
-import { promisify } from 'util';
 import { exec } from 'child_process';
-import { logger } from '../../../utils/logger.js';
-import { RequestContext } from '../../../utils/requestContext.js';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js';
-import { sanitization } from '../../../utils/sanitization.js';
+import { promisify } from 'util';
+import { z } from 'zod';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (RequestContext from ../utils/internal/requestContext.js)
+import { BaseErrorCode, McpError } from '../../../types-global/errors.js'; // Keep direct import for types-global
+import { RequestContext } from '../../../utils/index.js';
+// Import utils from barrel (sanitization from ../utils/security/sanitization.js)
+import { sanitization } from '../../../utils/index.js';
 
 const execAsync = promisify(exec);
 
diff --git a/src/mcp-server/tools/gitPush/registration.ts b/src/mcp-server/tools/gitPush/registration.ts
index d1504f9..13b31fb 100644
--- a/src/mcp-server/tools/gitPush/registration.ts
+++ b/src/mcp-server/tools/gitPush/registration.ts
@@ -1,11 +1,13 @@
 import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
 import { CallToolResult, TextContent } from '@modelcontextprotocol/sdk/types.js';
-import { z } from 'zod';
-import { ErrorHandler } from '../../../utils/errorHandler.js';
-import { logger } from '../../../utils/logger.js';
-import { requestContextService, RequestContext } from '../../../utils/requestContext.js';
-import { GitPushInputSchema, pushGitChanges, GitPushInput, GitPushResult } from './logic.js';
-import { BaseErrorCode, McpError } from '../../../types-global/errors.js';
+// Import utils from barrel (ErrorHandler from ../utils/internal/errorHandler.js)
+import { ErrorHandler } from '../../../utils/index.js';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (requestContextService, RequestContext from ../utils/internal/requestContext.js)
+import { BaseErrorCode } from '../../../types-global/errors.js'; // Keep direct import for types-global
+import { requestContextService } from '../../../utils/index.js';
+import { GitPushInput, GitPushInputSchema, GitPushResult, pushGitChanges } from './logic.js';
 
 // --- State Accessors ---
 // These functions need to be provided by the server setup layer (server.ts)
diff --git a/src/mcp-server/tools/gitRebase/logic.ts b/src/mcp-server/tools/gitRebase/logic.ts
index e701e80..51446b3 100644
--- a/src/mcp-server/tools/gitRebase/logic.ts
+++ b/src/mcp-server/tools/gitRebase/logic.ts
@@ -1,10 +1,13 @@
-import { z } from 'zod';
+import { exec } from 'child_process';
 import { promisify } from 'util';
-import { exec, ExecException } from 'child_process';
-import { logger } from '../../../utils/logger.js';
-import { RequestContext } from '../../../utils/requestContext.js';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js';
-import { sanitization } from '../../../utils/sanitization.js';
+import { z } from 'zod';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (RequestContext from ../utils/internal/requestContext.js)
+import { BaseErrorCode, McpError } from '../../../types-global/errors.js'; // Keep direct import for types-global
+import { RequestContext } from '../../../utils/index.js';
+// Import utils from barrel (sanitization from ../utils/security/sanitization.js)
+import { sanitization } from '../../../utils/index.js';
 
 const execAsync = promisify(exec);
 
diff --git a/src/mcp-server/tools/gitRebase/registration.ts b/src/mcp-server/tools/gitRebase/registration.ts
index 08f6621..35dc398 100644
--- a/src/mcp-server/tools/gitRebase/registration.ts
+++ b/src/mcp-server/tools/gitRebase/registration.ts
@@ -1,10 +1,13 @@
 import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
 import { CallToolResult, TextContent } from '@modelcontextprotocol/sdk/types.js';
-import { logger } from '../../../utils/logger.js';
-import { ErrorHandler } from '../../../utils/errorHandler.js';
-import { requestContextService } from '../../../utils/requestContext.js';
-import { gitRebaseLogic, GitRebaseInputSchema, GitRebaseInput, GitRebaseResult, GitRebaseBaseSchema } from './logic.js';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js';
+// Import utils from barrel (logger from ../utils/internal/logger.js)
+import { logger } from '../../../utils/index.js';
+// Import utils from barrel (ErrorHandler from ../utils/internal/errorHandler.js)
+import { ErrorHandler } from '../../../utils/index.js';
+// Import utils from barrel (requestContextService from ../utils/internal/requestContext.js)
+import { BaseErrorCode } from '../../../types-global/errors.js'; // Keep direct import for types-global
+import { requestContextService } from '../../../utils/index.js';
+import { GitRebaseBaseSchema, GitRebaseInput, gitRebaseLogic, GitRebaseResult } from './logic.js';
 
 // --- State Accessors ---
 export type GetWorkingDirectoryFn = (sessionId: string | undefined) => string | undefined;
diff --git a/src/mcp-server/tools/gitRemote/logic.ts b/src/mcp-server/tools/gitRemote/logic.ts
index 10cb3be..f118b88 100644
--- a/src/mcp-server/tools/gitRemote/logic.ts
+++ b/src/mcp-server/tools/gitRemote/logic.ts
@@ -1,10 +1,8 @@
 import { exec } from 'child_process';
 import { promisify } from 'util';
 import { z } from 'zod';
-import { BaseErrorCode, McpError } from '../../../types-global/errors.js';
-import { logger } from '../../../utils/logger.js';
-import { RequestContext } from '../../../utils/requestContext.js';
-import { sanitization } from '../../../utils/sanitization.js';
+import { BaseErrorCode, McpError } from '../../../types-global/errors.js'; // Direct import for types-global
+import { logger, RequestContext, sanitization } from '../../../utils/index.js'; // Logger (./utils/internal/logger.js) & RequestContext (./utils/internal/requestContext.js) & sanitization (./utils/security/sanitization.js)
 
 const execAsync = promisify(exec);
 
diff --git a/src/mcp-server/tools/gitRemote/registration.ts b/src/mcp-server/tools/gitRemote/registration.ts
index 658197c..b016d7e 100644
--- a/src/mcp-server/tools/gitRemote/registration.ts
+++ b/src/mcp-server/tools/gitRemote/registration.ts
@@ -1,9 +1,7 @@
 import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
 import { CallToolResult, TextContent } from '@modelcontextprotocol/sdk/types.js';
-import { BaseErrorCode } from '../../../types-global/errors.js';
-import { ErrorHandler } from '../../../utils/errorHandler.js';
-import { logger } from '../../../utils/logger.js';
-import { requestContextService } from '../../../utils/requestContext.js';
+import { BaseErrorCode } from '../../../types-global/errors.js'; // Direct import for types-global
+import { ErrorHandler, logger, requestContextService } from '../../../utils/index.js'; // ErrorHandler (./utils/internal/errorHandler.js), logger (./utils/internal/logger.js), requestContextService (./utils/internal/requestContext.js)
 import { GitRemoteInput, GitRemoteInputSchema, gitRemoteLogic, GitRemoteResult } from './logic.js';
 
 // --- State Accessors ---
diff --git a/src/mcp-server/tools/gitReset/logic.ts b/src/mcp-server/tools/gitReset/logic.ts
index d85cc8b..af80008 100644
--- a/src/mcp-server/tools/gitReset/logic.ts
+++ b/src/mcp-server/tools/gitReset/logic.ts
@@ -1,10 +1,8 @@
-import { z } from 'zod';
-import { promisify } from 'util';
 import { exec } from 'child_process';
-import { logger } from '../../../utils/logger.js';
-import { RequestContext } from '../../../utils/requestContext.js';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js';
-import { sanitization } from '../../../utils/sanitization.js';
+import { promisify } from 'util';
+import { z } from 'zod';
+import { BaseErrorCode, McpError } from '../../../types-global/errors.js'; // Direct import for types-global
+import { logger, RequestContext, sanitization } from '../../../utils/index.js'; // logger (./utils/internal/logger.js), RequestContext (./utils/internal/requestContext.js), sanitization (./utils/security/sanitization.js)
 
 const execAsync = promisify(exec);
 
diff --git a/src/mcp-server/tools/gitReset/registration.ts b/src/mcp-server/tools/gitReset/registration.ts
index 1c4ed05..71d19be 100644
--- a/src/mcp-server/tools/gitReset/registration.ts
+++ b/src/mcp-server/tools/gitReset/registration.ts
@@ -1,11 +1,8 @@
 import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
 import { CallToolResult, TextContent } from '@modelcontextprotocol/sdk/types.js';
-import { z } from 'zod';
-import { ErrorHandler } from '../../../utils/errorHandler.js';
-import { logger } from '../../../utils/logger.js';
-import { requestContextService, RequestContext } from '../../../utils/requestContext.js';
-import { GitResetInputSchema, resetGitState, GitResetInput, GitResetResult } from './logic.js';
-import { BaseErrorCode, McpError } from '../../../types-global/errors.js';
+import { BaseErrorCode } from '../../../types-global/errors.js'; // Direct import for types-global
+import { ErrorHandler, logger, requestContextService } from '../../../utils/index.js'; // ErrorHandler (./utils/internal/errorHandler.js), logger (./utils/internal/logger.js), requestContextService & RequestContext (./utils/internal/requestContext.js)
+import { GitResetInput, GitResetInputSchema, GitResetResult, resetGitState } from './logic.js';
 
 // --- State Accessors ---
 // These functions need to be provided by the server setup layer (server.ts)
diff --git a/src/mcp-server/tools/gitSetWorkingDir/logic.ts b/src/mcp-server/tools/gitSetWorkingDir/logic.ts
index 91ea641..f8b6572 100644
--- a/src/mcp-server/tools/gitSetWorkingDir/logic.ts
+++ b/src/mcp-server/tools/gitSetWorkingDir/logic.ts
@@ -1,12 +1,9 @@
-import { z } from 'zod';
 import { exec } from 'child_process';
-import { promisify } from 'util';
-import path from 'path';
 import fs from 'fs/promises';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js';
-import { RequestContext } from '../../../utils/requestContext.js';
-import { logger } from '../../../utils/logger.js';
-import { sanitization } from '../../../utils/sanitization.js';
+import { promisify } from 'util';
+import { z } from 'zod';
+import { BaseErrorCode, McpError } from '../../../types-global/errors.js'; // Direct import for types-global
+import { RequestContext, logger, sanitization } from '../../../utils/index.js'; // RequestContext (./utils/internal/requestContext.js), logger (./utils/internal/logger.js), sanitization (./utils/security/sanitization.js)
 
 const execAsync = promisify(exec);
 
diff --git a/src/mcp-server/tools/gitSetWorkingDir/registration.ts b/src/mcp-server/tools/gitSetWorkingDir/registration.ts
index 4aad011..baaada3 100644
--- a/src/mcp-server/tools/gitSetWorkingDir/registration.ts
+++ b/src/mcp-server/tools/gitSetWorkingDir/registration.ts
@@ -1,11 +1,8 @@
 import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
 import { CallToolResult, TextContent } from '@modelcontextprotocol/sdk/types.js';
-import { z } from 'zod';
-import { ErrorHandler } from '../../../utils/errorHandler.js';
-import { logger } from '../../../utils/logger.js';
-import { requestContextService, RequestContext } from '../../../utils/requestContext.js';
-import { GitSetWorkingDirInputSchema, gitSetWorkingDirLogic, GitSetWorkingDirInput } from './logic.js';
-import { BaseErrorCode, McpError } from '../../../types-global/errors.js';
+import { BaseErrorCode } from '../../../types-global/errors.js'; // Direct import for types-global
+import { ErrorHandler, logger, requestContextService } from '../../../utils/index.js'; // ErrorHandler (./utils/internal/errorHandler.js), logger (./utils/internal/logger.js), requestContextService & RequestContext (./utils/internal/requestContext.js)
+import { GitSetWorkingDirInput, GitSetWorkingDirInputSchema, gitSetWorkingDirLogic } from './logic.js';
 
 // --- State Accessors ---
 // These functions need to be provided by the server setup layer (server.ts)
diff --git a/src/mcp-server/tools/gitShow/logic.ts b/src/mcp-server/tools/gitShow/logic.ts
index 02a5e42..2d7ce92 100644
--- a/src/mcp-server/tools/gitShow/logic.ts
+++ b/src/mcp-server/tools/gitShow/logic.ts
@@ -1,10 +1,8 @@
-import { z } from 'zod';
-import { promisify } from 'util';
 import { exec } from 'child_process';
-import { logger } from '../../../utils/logger.js';
-import { RequestContext } from '../../../utils/requestContext.js';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js';
-import { sanitization } from '../../../utils/sanitization.js';
+import { promisify } from 'util';
+import { z } from 'zod';
+import { BaseErrorCode, McpError } from '../../../types-global/errors.js'; // Direct import for types-global
+import { logger, RequestContext, sanitization } from '../../../utils/index.js'; // logger (./utils/internal/logger.js), RequestContext (./utils/internal/requestContext.js), sanitization (./utils/security/sanitization.js)
 
 const execAsync = promisify(exec);
 
diff --git a/src/mcp-server/tools/gitShow/registration.ts b/src/mcp-server/tools/gitShow/registration.ts
index c5f87dc..78f448b 100644
--- a/src/mcp-server/tools/gitShow/registration.ts
+++ b/src/mcp-server/tools/gitShow/registration.ts
@@ -1,11 +1,9 @@
 import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
 import { CallToolResult, TextContent } from '@modelcontextprotocol/sdk/types.js';
-import { logger } from '../../../utils/logger.js';
-import { ErrorHandler } from '../../../utils/errorHandler.js';
-import { requestContextService } from '../../../utils/requestContext.js';
+import { BaseErrorCode } from '../../../types-global/errors.js'; // Direct import for types-global
+import { ErrorHandler, logger, requestContextService } from '../../../utils/index.js'; // logger (./utils/internal/logger.js), ErrorHandler (./utils/internal/errorHandler.js), requestContextService (./utils/internal/requestContext.js)
 // Import the schema and types
-import { gitShowLogic, GitShowInputSchema, GitShowInput, GitShowResult } from './logic.js';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js';
+import { GitShowInput, GitShowInputSchema, gitShowLogic, GitShowResult } from './logic.js';
 
 // --- State Accessors ---
 /** Type definition for the function that gets the working directory for a session */
diff --git a/src/mcp-server/tools/gitStash/logic.ts b/src/mcp-server/tools/gitStash/logic.ts
index a9dd011..500065f 100644
--- a/src/mcp-server/tools/gitStash/logic.ts
+++ b/src/mcp-server/tools/gitStash/logic.ts
@@ -1,10 +1,8 @@
-import { z } from 'zod';
-import { promisify } from 'util';
 import { exec } from 'child_process';
-import { logger } from '../../../utils/logger.js';
-import { RequestContext } from '../../../utils/requestContext.js';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js';
-import { sanitization } from '../../../utils/sanitization.js';
+import { promisify } from 'util';
+import { z } from 'zod';
+import { BaseErrorCode, McpError } from '../../../types-global/errors.js'; // Direct import for types-global
+import { logger, RequestContext, sanitization } from '../../../utils/index.js'; // logger (./utils/internal/logger.js), RequestContext (./utils/internal/requestContext.js), sanitization (./utils/security/sanitization.js)
 
 const execAsync = promisify(exec);
 
diff --git a/src/mcp-server/tools/gitStash/registration.ts b/src/mcp-server/tools/gitStash/registration.ts
index c54551c..9d63ba4 100644
--- a/src/mcp-server/tools/gitStash/registration.ts
+++ b/src/mcp-server/tools/gitStash/registration.ts
@@ -1,12 +1,10 @@
 import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
 import { CallToolResult, TextContent } from '@modelcontextprotocol/sdk/types.js';
-import { logger } from '../../../utils/logger.js';
-import { ErrorHandler } from '../../../utils/errorHandler.js';
-import { requestContextService } from '../../../utils/requestContext.js';
+import { BaseErrorCode } from '../../../types-global/errors.js'; // Direct import for types-global
+import { ErrorHandler, logger, requestContextService } from '../../../utils/index.js'; // logger (./utils/internal/logger.js), ErrorHandler (./utils/internal/errorHandler.js), requestContextService (./utils/internal/requestContext.js)
 // Import the final schema and types for handler logic
 // Import the BASE schema separately for registration shape
-import { gitStashLogic, GitStashInputSchema, GitStashInput, GitStashResult, GitStashBaseSchema } from './logic.js';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js';
+import { GitStashBaseSchema, GitStashInput, gitStashLogic, GitStashResult } from './logic.js';
 
 // --- State Accessors ---
 /** Type definition for the function that gets the working directory for a session */
diff --git a/src/mcp-server/tools/gitStatus/logic.ts b/src/mcp-server/tools/gitStatus/logic.ts
index 11c13a3..a177ad6 100644
--- a/src/mcp-server/tools/gitStatus/logic.ts
+++ b/src/mcp-server/tools/gitStatus/logic.ts
@@ -1,11 +1,8 @@
-import { z } from 'zod';
-import { promisify } from 'util';
 import { exec } from 'child_process';
-import { logger } from '../../../utils/logger.js';
-import { RequestContext } from '../../../utils/requestContext.js';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js';
-import { sanitization } from '../../../utils/sanitization.js';
-import path from 'path'; // Import path module
+import { promisify } from 'util';
+import { z } from 'zod';
+import { BaseErrorCode, McpError } from '../../../types-global/errors.js'; // Direct import for types-global
+import { logger, RequestContext, sanitization } from '../../../utils/index.js'; // logger (./utils/internal/logger.js), RequestContext (./utils/internal/requestContext.js), sanitization (./utils/security/sanitization.js)
 
 const execAsync = promisify(exec);
 
diff --git a/src/mcp-server/tools/gitStatus/registration.ts b/src/mcp-server/tools/gitStatus/registration.ts
index 2b188f2..efb9647 100644
--- a/src/mcp-server/tools/gitStatus/registration.ts
+++ b/src/mcp-server/tools/gitStatus/registration.ts
@@ -1,11 +1,9 @@
 import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
 import { CallToolResult, TextContent } from '@modelcontextprotocol/sdk/types.js';
-import { logger } from '../../../utils/logger.js';
-import { ErrorHandler } from '../../../utils/errorHandler.js';
-import { requestContextService } from '../../../utils/requestContext.js';
+import { BaseErrorCode } from '../../../types-global/errors.js'; // Direct import for types-global
+import { ErrorHandler, logger, requestContextService } from '../../../utils/index.js'; // logger (./utils/internal/logger.js), ErrorHandler (./utils/internal/errorHandler.js), requestContextService (./utils/internal/requestContext.js)
 // Import the result type along with the function and input schema
-import { getGitStatus, GitStatusInputSchema, GitStatusInput, GitStatusResult } from './logic.js';
-import { McpError, BaseErrorCode } from '../../../types-global/errors.js'; // Import BaseErrorCode
+import { getGitStatus, GitStatusInput, GitStatusInputSchema, GitStatusResult } from './logic.js';
 
 // --- State Accessors ---
 /** Type definition for the function that gets the working directory for a session */
diff --git a/src/mcp-server/tools/gitTag/logic.ts b/src/mcp-server/tools/gitTag/logic.ts
index 7aac266..1111c3e 100644
--- a/src/mcp-server/tools/gitTag/logic.ts
+++ b/src/mcp-server/tools/gitTag/logic.ts
@@ -1,10 +1,8 @@
 import { exec } from 'child_process';
 import { promisify } from 'util';
 import { z } from 'zod';
-import { BaseErrorCode, McpError } from '../../../types-global/errors.js';
-import { logger } from '../../../utils/logger.js';
-import { RequestContext } from '../../../utils/requestContext.js';
-import { sanitization } from '../../../utils/sanitization.js';
+import { BaseErrorCode, McpError } from '../../../types-global/errors.js'; // Direct import for types-global
+import { logger, RequestContext, sanitization } from '../../../utils/index.js'; // logger (./utils/internal/logger.js), RequestContext (./utils/internal/requestContext.js), sanitization (./utils/security/sanitization.js)
 
 const execAsync = promisify(exec);
 
diff --git a/src/mcp-server/tools/gitTag/registration.ts b/src/mcp-server/tools/gitTag/registration.ts
index c92a532..064e189 100644
--- a/src/mcp-server/tools/gitTag/registration.ts
+++ b/src/mcp-server/tools/gitTag/registration.ts
@@ -1,11 +1,9 @@
 import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
 import { CallToolResult, TextContent } from '@modelcontextprotocol/sdk/types.js';
-import { ErrorHandler } from '../../../utils/errorHandler.js';
-import { logger } from '../../../utils/logger.js';
-import { requestContextService } from '../../../utils/requestContext.js';
+import { BaseErrorCode } from '../../../types-global/errors.js'; // Direct import for types-global
+import { ErrorHandler, logger, requestContextService } from '../../../utils/index.js'; // ErrorHandler (./utils/internal/errorHandler.js), logger (./utils/internal/logger.js), requestContextService (./utils/internal/requestContext.js)
 // Import the final schema and types for handler logic
 // Import the BASE schema separately for registration shape
-import { BaseErrorCode } from '../../../types-global/errors.js';
 import { GitTagBaseSchema, GitTagInput, gitTagLogic, GitTagResult } from './logic.js';
 
 // --- State Accessors ---
diff --git a/src/types-global/tool.ts b/src/types-global/tool.ts
index 919e275..c61d290 100644
--- a/src/types-global/tool.ts
+++ b/src/types-global/tool.ts
@@ -1,5 +1,5 @@
 import { z } from 'zod';
-import { OperationContext } from "../utils/requestContext.js"; // Updated import
+import { OperationContext } from '../utils/index.js'; // OperationContext (./utils/internal/requestContext.js)
 import { McpToolResult } from './mcp.js'; // Renamed McpToolResponse to McpToolResult
 
 /**
diff --git a/src/utils/errorHandler.ts b/src/utils/errorHandler.ts
deleted file mode 100644
index 4e38c84..0000000
--- a/src/utils/errorHandler.ts
+++ /dev/null
@@ -1,347 +0,0 @@
-import { BaseErrorCode, McpError } from '../types-global/errors.js';
-import { logger } from './logger.js';
-import { sanitizeInputForLogging } from './sanitization.js'; // Updated import
-
-/**
- * Generic error context interface
- */
-export interface ErrorContext {
-  /** Unique request or operation identifier */
-  requestId?: string;
-  /** Any additional context information */
-  [key: string]: unknown;
-}
-
-/**
- * Error handler options
- */
-export interface ErrorHandlerOptions {
-  /** The context of the operation that caused the error */
-  context?: ErrorContext;
-  /** The name of the operation being performed */
-  operation: string;
-  /** The input that caused the error */
-  input?: unknown;
-  /** Whether to rethrow the error after handling */
-  rethrow?: boolean;
-  /** Custom error code to use when creating an McpError */
-  errorCode?: BaseErrorCode;
-  /** Custom error mapper function */
-  errorMapper?: (error: unknown) => Error;
-  /** Whether to include stack traces in logs */
-  includeStack?: boolean;
-  /** Whether this is a critical error that should abort operations */
-  critical?: boolean;
-}
-
-/**
- * Base error mapping rule
- */
-export interface BaseErrorMapping {
-  /** Pattern to match in the error message */
-  pattern: string | RegExp;
-  /** Error code for mapped errors */
-  errorCode: BaseErrorCode;
-  /** Custom error message template */
-  messageTemplate?: string;
-}
-
-/**
- * Error mapping configuration
- */
-export interface ErrorMapping<T extends Error = Error> extends BaseErrorMapping {
-  /** Factory function to create the mapped error */
-  factory: (error: unknown, context?: Record<string, unknown>) => T;
-  /** Additional context to merge with error context */
-  additionalContext?: Record<string, unknown>;
-}
-
-/**
- * Simple mapper that maps error types to error codes
- */
-const ERROR_TYPE_MAPPINGS: Record<string, BaseErrorCode> = {
-  'SyntaxError': BaseErrorCode.VALIDATION_ERROR,
-  'TypeError': BaseErrorCode.VALIDATION_ERROR,
-  'ReferenceError': BaseErrorCode.INTERNAL_ERROR,
-  'RangeError': BaseErrorCode.VALIDATION_ERROR,
-  'URIError': BaseErrorCode.VALIDATION_ERROR,
-  'EvalError': BaseErrorCode.INTERNAL_ERROR
-};
-
-/**
- * Common error patterns for automatic classification
- */
-const COMMON_ERROR_PATTERNS: BaseErrorMapping[] = [
-  // Authentication related errors
-  { pattern: /auth|unauthorized|unauthenticated|not.*logged.*in|invalid.*token|expired.*token/i, errorCode: BaseErrorCode.UNAUTHORIZED },
-  // Permission related errors
-  { pattern: /permission|forbidden|access.*denied|not.*allowed/i, errorCode: BaseErrorCode.FORBIDDEN },
-  // Not found errors
-  { pattern: /not.*found|missing|no.*such|doesn't.*exist|couldn't.*find/i, errorCode: BaseErrorCode.NOT_FOUND },
-  // Validation errors
-  { pattern: /invalid|validation|malformed|bad request|wrong format/i, errorCode: BaseErrorCode.VALIDATION_ERROR },
-  // Conflict errors
-  { pattern: /conflict|already.*exists|duplicate|unique.*constraint/i, errorCode: BaseErrorCode.CONFLICT },
-  // Rate limiting
-  { pattern: /rate.*limit|too.*many.*requests|throttled/i, errorCode: BaseErrorCode.RATE_LIMITED },
-  // Timeout errors
-  { pattern: /timeout|timed.*out|deadline.*exceeded/i, errorCode: BaseErrorCode.TIMEOUT },
-  // External service errors
-  { pattern: /service.*unavailable|bad.*gateway|gateway.*timeout/i, errorCode: BaseErrorCode.SERVICE_UNAVAILABLE }
-];
-
-/**
- * Get a readable name for an error
- * @param error Error to get name for
- * @returns User-friendly error name
- */
-function getErrorName(error: unknown): string {
-  if (error instanceof Error) {
-    return error.name || 'Error';
-  }
-  
-  if (error === null) {
-    return 'NullError';
-  }
-  
-  if (error === undefined) {
-    return 'UndefinedError';
-  }
-  
-  return typeof error === 'object' 
-    ? 'ObjectError' 
-    : 'UnknownError';
-}
-
-/**
- * Get a message from an error
- * @param error Error to get message from
- * @returns Error message
- */
-function getErrorMessage(error: unknown): string {
-  if (error instanceof Error) {
-    return error.message;
-  }
-  
-  if (error === null) {
-    return 'Null error occurred';
-  }
-  
-  if (error === undefined) {
-    return 'Undefined error occurred';
-  }
-  
-  return typeof error === 'string' 
-    ? error 
-    : String(error);
-}
-
-/**
- * Error handler utility class with various error handling methods
- */
-export class ErrorHandler {
-  /**
-   * Determine the appropriate error code for an error based on patterns and type
-   * @param error The error to classify
-   * @returns The appropriate error code
-   */
-  public static determineErrorCode(error: unknown): BaseErrorCode {
-    // If it's already an McpError, use its code
-    if (error instanceof McpError) {
-      return error.code;
-    }
-    
-    const errorName = getErrorName(error);
-    const errorMessage = getErrorMessage(error);
-    
-    // Check if the error type has a direct mapping
-    if (errorName in ERROR_TYPE_MAPPINGS) {
-      return ERROR_TYPE_MAPPINGS[errorName as keyof typeof ERROR_TYPE_MAPPINGS];
-    }
-    
-    // Check for common error patterns
-    for (const pattern of COMMON_ERROR_PATTERNS) {
-      const regex = pattern.pattern instanceof RegExp 
-        ? pattern.pattern 
-        : new RegExp(pattern.pattern, 'i');
-        
-      if (regex.test(errorMessage) || regex.test(errorName)) {
-        return pattern.errorCode;
-      }
-    }
-    
-    // Default to internal error if no pattern matches
-    return BaseErrorCode.INTERNAL_ERROR;
-  }
-  
-  /**
-   * Handle operation errors with consistent logging and transformation
-   * @param error The error that occurred
-   * @param options Error handling options
-   * @returns The transformed error
-   */
-  public static handleError(error: unknown, options: ErrorHandlerOptions): Error {
-    const { 
-      context, 
-      operation, 
-      input, 
-      rethrow = false, 
-      errorCode: explicitErrorCode,
-      includeStack = true,
-      critical = false
-    } = options;
-    
-    // If it's already an McpError, use it directly but apply additional context
-    if (error instanceof McpError) {
-      // Add any additional context
-      if (context && Object.keys(context).length > 0) {
-        error.details = { ...error.details, ...context };
-      }
-      
-      // Log the error with sanitized input
-      logger.error(`Error ${operation}: ${error.message}`, {
-        errorCode: error.code,
-        requestId: context?.requestId,
-        input: input ? sanitizeInputForLogging(input) : undefined,
-        stack: includeStack ? error.stack : undefined,
-        critical,
-        ...context
-      });
-      
-      if (rethrow) {
-        throw error;
-      }
-      
-      return error;
-    }
-    
-    // Sanitize input for logging
-    const sanitizedInput = input ? sanitizeInputForLogging(input) : undefined;
-    
-    // Log the error with consistent format
-    logger.error(`Error ${operation}`, {
-      error: error instanceof Error ? error.message : String(error),
-      errorType: getErrorName(error),
-      input: sanitizedInput,
-      requestId: context?.requestId,
-      stack: includeStack && error instanceof Error ? error.stack : undefined,
-      critical,
-      ...context
-    });
-    
-    // Choose the error code (explicit > determined > default)
-    const errorCode = explicitErrorCode || 
-                      ErrorHandler.determineErrorCode(error) || 
-                      BaseErrorCode.INTERNAL_ERROR;
-    
-    // Transform to appropriate error type
-    const transformedError = options.errorMapper 
-      ? options.errorMapper(error)
-      : new McpError(
-          errorCode,
-          `Error ${operation}: ${error instanceof Error ? error.message : 'Unknown error'}`,
-          {
-            originalError: getErrorName(error),
-            ...context
-          }
-        );
-    
-    // Rethrow if requested
-    if (rethrow) {
-      throw transformedError;
-    }
-    
-    return transformedError;
-  }
-  
-  /**
-   * Map an error to a specific error type based on error message patterns
-   * @param error The error to map
-   * @param mappings Array of pattern and factory mappings
-   * @param defaultFactory Default factory function if no pattern matches
-   * @returns The mapped error
-   */
-  public static mapError<T extends Error>(
-    error: unknown, 
-    mappings: ErrorMapping<T>[], 
-    defaultFactory?: (error: unknown, context?: Record<string, unknown>) => T
-  ): T | Error {
-    // If it's already the target type and we have a default factory to check against, return it
-    if (defaultFactory && error instanceof Error) {
-      const defaultInstance = defaultFactory(error);
-      if (error.constructor === defaultInstance.constructor) {
-        return error as T;
-      }
-    }
-    
-    const errorMessage = getErrorMessage(error);
-    
-    // Check each pattern and return the first match
-    for (const mapping of mappings) {
-      const matches = mapping.pattern instanceof RegExp
-        ? mapping.pattern.test(errorMessage)
-        : errorMessage.includes(mapping.pattern);
-        
-      if (matches) {
-        return mapping.factory(error, mapping.additionalContext);
-      }
-    }
-    
-    // Return default or original error
-    if (defaultFactory) {
-      return defaultFactory(error);
-    }
-    
-    return error instanceof Error 
-      ? error
-      : new Error(String(error));
-  }
-  
-  // Removed createErrorMapper method for simplification
-  
-  /**
-   * Format an error for consistent response structure
-   * @param error The error to format
-   * @returns Formatted error object
-   */
-  public static formatError(error: unknown): Record<string, unknown> {
-    if (error instanceof McpError) {
-      return {
-        code: error.code,
-        message: error.message,
-        details: error.details || {}
-      };
-    }
-    
-    if (error instanceof Error) {
-      return {
-        code: ErrorHandler.determineErrorCode(error),
-        message: error.message,
-        details: { errorType: error.name }
-      };
-    }
-    
-    return {
-      code: BaseErrorCode.UNKNOWN_ERROR,
-      message: String(error),
-      details: { errorType: typeof error }
-    };
-  }
-  
-  /**
-   * Safely execute a function and handle any errors
-   * @param fn Function to execute
-   * @param options Error handling options
-   * @returns The result of the function or error
-   */
-  public static async tryCatch<T>(
-    fn: () => Promise<T> | T,
-    options: ErrorHandlerOptions
-  ): Promise<T> {
-    try {
-      return await fn();
-    } catch (error) {
-      throw ErrorHandler.handleError(error, { ...options, rethrow: true });
-    }
-  }
-}
diff --git a/src/utils/idGenerator.ts b/src/utils/idGenerator.ts
deleted file mode 100644
index c67e2e7..0000000
--- a/src/utils/idGenerator.ts
+++ /dev/null
@@ -1,209 +0,0 @@
-import { randomBytes } from 'crypto';
-import { BaseErrorCode, McpError } from '../types-global/errors.js';
-import { logger } from './logger.js';
-
-/**
- * Interface for entity prefix configuration
- */
-export interface EntityPrefixConfig {
-  [key: string]: string;
-}
-
-/**
- * ID Generation Options
- */
-export interface IdGenerationOptions {
-  length?: number;
-  separator?: string;
-  charset?: string;
-}
-
-/**
- * Generic ID Generator class for creating and managing unique identifiers
- */
-export class IdGenerator {
-  // Default charset
-  private static DEFAULT_CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
-  // Default separator
-  private static DEFAULT_SEPARATOR = '_';
-  // Default random part length
-  private static DEFAULT_LENGTH = 6;
-  // Entity prefixes
-  private entityPrefixes: EntityPrefixConfig = {};
-  // Reverse mapping for prefix to entity type lookup
-  private prefixToEntityType: Record<string, string> = {};
-
-  /**
-   * Constructor that accepts entity prefix configuration
-   * @param entityPrefixes Map of entity types to their prefixes
-   */
-  constructor(entityPrefixes: EntityPrefixConfig = {}) {
-    this.setEntityPrefixes(entityPrefixes);
-  }
-
-  /**
-   * Set or update entity prefixes and rebuild the reverse lookup
-   * @param entityPrefixes Map of entity types to their prefixes
-   */
-  public setEntityPrefixes(entityPrefixes: EntityPrefixConfig): void {
-    this.entityPrefixes = { ...entityPrefixes };
-    
-    // Rebuild reverse mapping
-    this.prefixToEntityType = Object.entries(this.entityPrefixes).reduce((acc, [type, prefix]) => {
-      acc[prefix] = type;
-      acc[prefix.toLowerCase()] = type;
-      return acc;
-    }, {} as Record<string, string>);
-    
-    logger.debug('Entity prefixes updated', { entityPrefixes: this.entityPrefixes });
-  }
-
-  /**
-   * Get all registered entity prefixes
-   * @returns The entity prefix configuration
-   */
-  public getEntityPrefixes(): EntityPrefixConfig {
-    return { ...this.entityPrefixes };
-  }
-
-  /**
-   * Generates a cryptographically secure random alphanumeric string
-   * @param length The length of the random string to generate
-   * @param charset Optional custom character set
-   * @returns Random alphanumeric string
-   */
-  public generateRandomString(
-    length: number = IdGenerator.DEFAULT_LENGTH,
-    charset: string = IdGenerator.DEFAULT_CHARSET
-  ): string {
-    const bytes = randomBytes(length);
-    let result = '';
-    
-    for (let i = 0; i < length; i++) {
-      result += charset[bytes[i] % charset.length];
-    }
-    
-    return result;
-  }
-
-  /**
-   * Generates a unique ID with an optional prefix
-   * @param prefix Optional prefix to add to the ID
-   * @param options Optional generation options
-   * @returns A unique identifier string
-   */
-  public generate(prefix?: string, options: IdGenerationOptions = {}): string {
-    const {
-      length = IdGenerator.DEFAULT_LENGTH,
-      separator = IdGenerator.DEFAULT_SEPARATOR,
-      charset = IdGenerator.DEFAULT_CHARSET
-    } = options;
-    
-    const randomPart = this.generateRandomString(length, charset);
-    
-    return prefix 
-      ? `${prefix}${separator}${randomPart}`
-      : randomPart;
-  }
-
-  /**
-   * Generates a custom ID for an entity with format PREFIX_XXXXXX
-   * @param entityType The type of entity to generate an ID for
-   * @param options Optional generation options
-   * @returns A unique identifier string (e.g., "PROJ_A6B3J0")
-   * @throws {McpError} If the entity type is not registered
-   */
-  public generateForEntity(entityType: string, options: IdGenerationOptions = {}): string {
-    const prefix = this.entityPrefixes[entityType];
-    
-    if (!prefix) {
-      throw new McpError(
-        BaseErrorCode.VALIDATION_ERROR,
-        `Unknown entity type: ${entityType}`
-      );
-    }
-    
-    return this.generate(prefix, options);
-  }
-
-  /**
-   * Validates if a given ID matches the expected format for an entity type
-   * @param id The ID to validate
-   * @param entityType The expected entity type
-   * @param options Optional validation options
-   * @returns boolean indicating if the ID is valid
-   */
-  public isValid(id: string, entityType: string, options: IdGenerationOptions = {}): boolean {
-    const prefix = this.entityPrefixes[entityType];
-    const { 
-      length = IdGenerator.DEFAULT_LENGTH,
-      separator = IdGenerator.DEFAULT_SEPARATOR
-    } = options;
-    
-    if (!prefix) {
-      return false;
-    }
-    
-    const pattern = new RegExp(`^${prefix}${separator}[A-Z0-9]{${length}}$`);
-    return pattern.test(id);
-  }
-
-  /**
-   * Strips the prefix from an ID
-   * @param id The ID to strip
-   * @param separator Optional custom separator
-   * @returns The ID without the prefix
-   */
-  public stripPrefix(id: string, separator: string = IdGenerator.DEFAULT_SEPARATOR): string {
-    return id.split(separator)[1] || id;
-  }
-
-  /**
-   * Determines the entity type from an ID
-   * @param id The ID to get the entity type for
-   * @param separator Optional custom separator
-   * @returns The entity type
-   * @throws {McpError} If the ID format is invalid or entity type is unknown
-   */
-  public getEntityType(id: string, separator: string = IdGenerator.DEFAULT_SEPARATOR): string {
-    const parts = id.split(separator);
-    if (parts.length !== 2 || !parts[0]) {
-      throw new McpError(
-        BaseErrorCode.VALIDATION_ERROR,
-        `Invalid ID format: ${id}. Expected format: PREFIX${separator}XXXXXX`
-      );
-    }
-
-    const prefix = parts[0];
-    const entityType = this.prefixToEntityType[prefix];
-    
-    if (!entityType) {
-      throw new McpError(
-        BaseErrorCode.VALIDATION_ERROR,
-        `Unknown entity type prefix: ${prefix}`
-      );
-    }
-
-    return entityType;
-  }
-
-  /**
-   * Normalizes an entity ID to ensure consistent uppercase format
-   * @param id The ID to normalize
-   * @param separator Optional custom separator
-   * @returns The normalized ID in uppercase format
-   */
-  public normalize(id: string, separator: string = IdGenerator.DEFAULT_SEPARATOR): string {
-    const entityType = this.getEntityType(id, separator);
-    const idParts = id.split(separator);
-    return `${this.entityPrefixes[entityType]}${separator}${idParts[1].toUpperCase()}`;
-  }
-}
-
-// Create and export a default instance with an empty entity prefix configuration
-export const idGenerator = new IdGenerator();
-
-// For standalone use as a UUID generator
-export const generateUUID = (): string => {
-  return crypto.randomUUID();
-};
diff --git a/src/utils/index.ts b/src/utils/index.ts
index 100eb50..7483eee 100644
--- a/src/utils/index.ts
+++ b/src/utils/index.ts
@@ -1,12 +1,5 @@
-// Re-export all utilities using wildcard exports for simplicity
-export * from './requestContext.js';
-export * from './errorHandler.js';
-export * from './idGenerator.js';
-export * from './logger.js';
-export * from './rateLimiter.js';
-export * from './sanitization.js';
-export * from './tokenCounter.js';
-export * from './jsonParser.js';
-
-// No need for explicit named imports/exports or default export
-// when using wildcard exports for a simple barrel file.
+// Re-export all utilities from their categorized subdirectories
+export * from './internal/index.js';
+export * from './parsing/index.js';
+export * from './security/index.js';
+export * from './metrics/index.js';
diff --git a/src/utils/jsonParser.ts b/src/utils/jsonParser.ts
deleted file mode 100644
index 16d593e..0000000
--- a/src/utils/jsonParser.ts
+++ /dev/null
@@ -1,96 +0,0 @@
-import { parse as parsePartialJson, Allow as PartialJsonAllow } from 'partial-json';
-import { BaseErrorCode, McpError } from '../types-global/errors.js';
-import { logger } from './logger.js'; // Import logger
-import { RequestContext } from './requestContext.js'; // Assuming context might be needed for error wrapping
-
-/**
- * Enum mirroring partial-json's Allow constants for specifying
- * what types of partial JSON structures are permissible during parsing.
- * Use bitwise OR to combine options (e.g., Allow.STR | Allow.OBJ).
- */
-export const Allow = PartialJsonAllow;
-
-// Regex to find a <think> block at the start, capturing its content and the rest of the string
-const thinkBlockRegex = /^<think>([\s\S]*?)<\/think>\s*([\s\S]*)$/;
-
-/**
- * Utility class for parsing potentially partial JSON strings.
- * Wraps the 'partial-json' library to provide a consistent interface
- * within the atlas-mcp-agent project.
- * Handles optional <think>...</think> blocks at the beginning of the input.
- */
-class JsonParser {
-  /**
-   * Parses a JSON string, potentially allowing for incomplete structures
-   * and handling optional <think> blocks at the start.
-   *
-   * @param jsonString The JSON string to parse.
-   * @param allowPartial A bitwise OR combination of 'Allow' constants specifying permissible partial types (defaults to Allow.ALL).
-   * @param context Optional RequestContext for error correlation and logging think blocks.
-   * @returns The parsed JavaScript value.
-   * @throws {McpError} Throws an McpError with BaseErrorCode.VALIDATION_ERROR if parsing fails due to malformed JSON.
-   */
-  parse<T = any>(jsonString: string, allowPartial: number = Allow.ALL, context?: RequestContext): T {
-    let stringToParse = jsonString;
-    const match = jsonString.match(thinkBlockRegex);
-
-    if (match) {
-      const thinkContent = match[1].trim();
-      const restOfString = match[2];
-
-      if (thinkContent) {
-        logger.debug('LLM <think> block detected and logged.', { ...context, thinkContent });
-      } else {
-        logger.debug('Empty LLM <think> block detected.', context);
-      }
-
-      stringToParse = restOfString; // Parse only the part after </think>
-    }
-
-    // Trim leading/trailing whitespace which might interfere with JSON parsing, especially if only JSON is left
-    stringToParse = stringToParse.trim();
-
-    if (!stringToParse) {
-        // If after removing think block and trimming, the string is empty, it's an error
-        throw new McpError(
-            BaseErrorCode.VALIDATION_ERROR,
-            'JSON string is empty after removing <think> block.',
-            context
-        );
-    }
-
-    try {
-      // Ensure the string starts with '{' or '[' if we expect an object or array after stripping <think>
-      // This helps catch cases where only non-JSON text remains.
-      if (!stringToParse.startsWith('{') && !stringToParse.startsWith('[')) {
-           // Check if it might be a simple string value that partial-json could parse
-           // Allow simple strings only if specifically permitted or Allow.ALL is used
-           const allowsString = (allowPartial & Allow.STR) === Allow.STR;
-           if (!allowsString && !stringToParse.startsWith('"')) { // Allow quoted strings if Allow.STR is set
-                throw new Error('Remaining content does not appear to be valid JSON object or array.');
-           }
-           // If it starts with a quote and strings are allowed, let parsePartialJson handle it
-      }
-
-      return parsePartialJson(stringToParse, allowPartial) as T;
-    } catch (error: any) {
-      // Wrap the original error in an McpError for consistent error handling
-      // Include the original error message for better debugging context.
-      logger.error('Failed to parse JSON content.', { ...context, error: error.message, contentAttempted: stringToParse });
-      throw new McpError(
-        BaseErrorCode.VALIDATION_ERROR,
-        `Failed to parse JSON: ${error.message}`,
-        { // Combine context and details into the third argument
-          ...context,
-          originalContent: stringToParse,
-          rawError: error instanceof Error ? error.stack : String(error) // Include raw error info
-        }
-      );
-    }
-  }
-}
-
-/**
- * Singleton instance of the JsonParser utility.
- */
-export const jsonParser = new JsonParser();
diff --git a/src/utils/logger.ts b/src/utils/logger.ts
deleted file mode 100644
index c879705..0000000
--- a/src/utils/logger.ts
+++ /dev/null
@@ -1,318 +0,0 @@
-import fs from 'fs';
-import path from 'path';
-import { fileURLToPath } from 'url';
-import winston from 'winston';
-import TransportStream from 'winston-transport';
-import { config } from '../config/index.js'; // Import config for logger name
-
-/**
- * Supported logging levels based on RFC 5424 Syslog severity levels used by MCP.
- * emerg: 0, alert: 1, crit: 2, error: 3, warning: 4, notice: 5, info: 6, debug: 7
- */
-export type McpLogLevel = 'debug' | 'info' | 'notice' | 'warning' | 'error' | 'crit' | 'alert' | 'emerg';
-
-// Define the numeric severity for comparison (lower is more severe)
-const mcpLevelSeverity: Record<McpLogLevel, number> = {
-  emerg: 0, alert: 1, crit: 2, error: 3, warning: 4, notice: 5, info: 6, debug: 7
-};
-
-// Map MCP levels to Winston's core levels for file logging
-const mcpToWinstonLevel: Record<McpLogLevel, 'debug' | 'info' | 'warn' | 'error'> = {
-  debug: 'debug',
-  info: 'info',
-  notice: 'info', // Map notice to info for file logging
-  warning: 'warn',
-  error: 'error',
-  crit: 'error',  // Map critical levels to error for file logging
-  alert: 'error',
-  emerg: 'error',
-};
-
-// Type for the MCP notification sender function
-export type McpNotificationSender = (level: McpLogLevel, data: any, loggerName?: string) => void;
-
-// Resolve __dirname for ESM
-const __filename = fileURLToPath(import.meta.url);
-const __dirname = path.dirname(__filename);
-
-// Project root assumed two levels above utils/
-const projectRoot = path.resolve(__dirname, '..', '..');
-const logsDir = path.join(projectRoot, 'logs');
-
-// Security: ensure logsDir is within projectRoot
-const resolvedLogsDir = path.resolve(logsDir);
-const isLogsDirSafe = resolvedLogsDir === projectRoot || resolvedLogsDir.startsWith(projectRoot + path.sep);
-if (!isLogsDirSafe) {
-  // Use console.error here as logger might not be initialized or safe
-  console.error(
-    `FATAL: logs directory "${resolvedLogsDir}" is outside project root "${projectRoot}". File logging disabled.`
-  );
-}
-
-/**
- * Singleton Logger wrapping Winston, adapted for MCP.
- * Logs to files and optionally sends MCP notifications/message.
- */
-class Logger {
-  private static instance: Logger;
-  private winstonLogger?: winston.Logger;
-  private initialized = false;
-  private mcpNotificationSender?: McpNotificationSender;
-  private currentMcpLevel: McpLogLevel = 'info'; // Default MCP level
-  private currentWinstonLevel: 'debug' | 'info' | 'warn' | 'error' = 'info'; // Default Winston level
-
-  private constructor() {}
-
-  /**
-   * Initialize Winston logger for file transport. Must be called once at app start.
-   * Console transport is removed.
-   * @param level Initial minimum level to log ('info' default).
-   */
-  public initialize(level: McpLogLevel = 'info'): void {
-    if (this.initialized) {
-      // Use console.warn as logger might be re-initializing
-      console.warn('Logger already initialized.');
-      return;
-    }
-    this.currentMcpLevel = level;
-    this.currentWinstonLevel = mcpToWinstonLevel[level];
-
-    // Ensure logs directory exists
-    if (isLogsDirSafe) {
-      try {
-        if (!fs.existsSync(resolvedLogsDir)) {
-          fs.mkdirSync(resolvedLogsDir, { recursive: true });
-          // Use console.log as logger isn't fully ready
-          console.log(`Created logs directory: ${resolvedLogsDir}`);
-        }
-      } catch (err: any) {
-        // Use console.error as logger isn't fully ready
-        console.error(
-          `Error creating logs directory at ${resolvedLogsDir}: ${err.message}. File logging disabled.`
-        );
-      }
-    }
-
-    // Common format for files
-    const fileFormat = winston.format.combine(
-      winston.format.timestamp(),
-      winston.format.errors({ stack: true }),
-      // Use JSON format for file logs for easier parsing
-      winston.format.json()
-    );
-
-    const transports: TransportStream[] = [];
-
-    // Add file transports only if the directory is safe
-    if (isLogsDirSafe) {
-      transports.push(
-        // Log levels equal to or more severe than the specified level
-        new winston.transports.File({ filename: path.join(resolvedLogsDir, 'error.log'), level: 'error', format: fileFormat }),
-        new winston.transports.File({ filename: path.join(resolvedLogsDir, 'warn.log'), level: 'warn', format: fileFormat }),
-        new winston.transports.File({ filename: path.join(resolvedLogsDir, 'info.log'), level: 'info', format: fileFormat }),
-        new winston.transports.File({ filename: path.join(resolvedLogsDir, 'debug.log'), level: 'debug', format: fileFormat }),
-        // Combined log captures everything based on the main logger level
-        new winston.transports.File({ filename: path.join(resolvedLogsDir, 'combined.log'), format: fileFormat })
-      );
-    } else {
-       // Use console.warn as logger isn't fully ready
-       console.warn("File logging disabled due to unsafe logs directory path.");
-    }
-
-    // Create logger with the initial Winston level and file transports
-    this.winstonLogger = winston.createLogger({
-        level: this.currentWinstonLevel, // Set Winston level for file logging
-        transports,
-        exitOnError: false
-    });
-
-    this.initialized = true;
-    // Log initialization message using the logger itself (will go to file)
-    this.info(`Logger initialized. File logging level: ${this.currentWinstonLevel}. MCP logging level: ${this.currentMcpLevel}`);
-  }
-
-  /**
-   * Sets the function used to send MCP 'notifications/message'.
-   * This should be called by the server logic once an MCP connection
-   * supporting logging is established.
-   * @param sender The function to call for sending notifications.
-   */
-  public setMcpNotificationSender(sender: McpNotificationSender | undefined): void {
-    this.mcpNotificationSender = sender;
-    const status = sender ? 'enabled' : 'disabled';
-    this.info(`MCP notification sending ${status}.`);
-  }
-
-  /**
-   * Dynamically sets the minimum logging level for both file logging and MCP notifications.
-   * @param newLevel The new minimum MCP log level.
-   */
-  public setLevel(newLevel: McpLogLevel): void {
-    if (!this.ensureInitialized()) {
-      // Use console.error as logger state is uncertain
-      console.error("Cannot set level: Logger not initialized.");
-      return;
-    }
-
-    // Validate the level
-    if (!(newLevel in mcpLevelSeverity)) {
-       this.warning(`Invalid MCP log level provided: ${newLevel}. Level not changed.`);
-       return;
-    }
-
-    this.currentMcpLevel = newLevel;
-    this.currentWinstonLevel = mcpToWinstonLevel[newLevel];
-    this.winstonLogger!.level = this.currentWinstonLevel; // Update Winston level for files
-
-    this.info(`Log level set. File logging level: ${this.currentWinstonLevel}. MCP logging level: ${this.currentMcpLevel}`);
-  }
-
-
-  /** Get singleton instance. */
-  public static getInstance(): Logger {
-    if (!Logger.instance) {
-      Logger.instance = new Logger();
-    }
-    return Logger.instance;
-  }
-
-  /** Ensures the logger has been initialized. */
-  private ensureInitialized(): boolean {
-    if (!this.initialized || !this.winstonLogger) {
-      // Use console.warn as this indicates a programming error (calling log before init)
-      console.warn('Logger not initialized; message dropped.');
-      return false;
-    }
-    return true;
-  }
-
-  /** Centralized log processing */
-  private log(level: McpLogLevel, msg: string, context?: Record<string, any>, error?: Error): void {
-    if (!this.ensureInitialized()) return;
-
-    // Check if message level is severe enough for current setting
-    if (mcpLevelSeverity[level] > mcpLevelSeverity[this.currentMcpLevel]) {
-      return; // Skip logging if level is less severe than current setting
-    }
-
-    const logData: Record<string, any> = { ...context }; // Copy context
-    const winstonLevel = mcpToWinstonLevel[level];
-
-    // Log to Winston (files)
-    if (error) {
-      // Include error details for Winston file log
-      logData.error = { message: error.message, stack: error.stack };
-      this.winstonLogger!.log(winstonLevel, msg, logData);
-    } else {
-      this.winstonLogger!.log(winstonLevel, msg, logData);
-    }
-
-
-    // Send MCP notification if sender is configured
-    if (this.mcpNotificationSender) {
-        // Prepare data for MCP: combine message and context/error info
-        const mcpDataPayload: any = { message: msg };
-        if (context) {
-            mcpDataPayload.context = context;
-        }
-        if (error) {
-            // Include simplified error info for MCP notification
-            mcpDataPayload.error = { message: error.message };
-            // Optionally include stack in debug mode? Be cautious about size.
-            if (this.currentMcpLevel === 'debug' && error.stack) {
-                 mcpDataPayload.error.stack = error.stack.substring(0, 500); // Limit stack trace size
-            }
-        }
-        try {
-             this.mcpNotificationSender(level, mcpDataPayload, config.mcpServerName);
-        } catch (sendError) {
-            // Log failure to send MCP notification to file log
-            this.winstonLogger!.error("Failed to send MCP log notification", {
-                originalLevel: level,
-                originalMessage: msg,
-                sendError: sendError instanceof Error ? sendError.message : String(sendError),
-                mcpPayload: mcpDataPayload // Log what we tried to send
-            });
-        }
-    }
-  }
-
-  // --- Public Logging Methods ---
-
-  /** Log debug message (level 7) */
-  public debug(msg: string, context?: Record<string, any>): void {
-    this.log('debug', msg, context);
-  }
-
-  /** Log info message (level 6) */
-  public info(msg: string, context?: Record<string, any>): void {
-    this.log('info', msg, context);
-  }
-
-  /** Log notice message (level 5) */
-  public notice(msg: string, context?: Record<string, any>): void {
-    this.log('notice', msg, context);
-  }
-
-  /** Log warning message (level 4) */
-  public warning(msg: string, context?: Record<string, any>): void {
-    this.log('warning', msg, context);
-  }
-
-  /** Log error message (level 3) */
-  public error(msg: string, err?: Error | Record<string, any>, context?: Record<string, any>): void {
-    if (err instanceof Error) {
-      this.log('error', msg, context, err);
-    } else {
-      // If err is not an Error object, treat it as additional context
-      const combinedContext = { ...(err || {}), ...(context || {}) };
-      this.log('error', msg, combinedContext);
-    }
-  }
-
-   /** Log critical message (level 2) */
-   public crit(msg: string, err?: Error | Record<string, any>, context?: Record<string, any>): void {
-    if (err instanceof Error) {
-      this.log('crit', msg, context, err);
-    } else {
-      const combinedContext = { ...(err || {}), ...(context || {}) };
-      this.log('crit', msg, combinedContext);
-    }
-  }
-
-  /** Log alert message (level 1) */
-  public alert(msg: string, err?: Error | Record<string, any>, context?: Record<string, any>): void {
-     if (err instanceof Error) {
-      this.log('alert', msg, context, err);
-    } else {
-      const combinedContext = { ...(err || {}), ...(context || {}) };
-      this.log('alert', msg, combinedContext);
-    }
-  }
-
-  /** Log emergency message (level 0) */
-  public emerg(msg: string, err?: Error | Record<string, any>, context?: Record<string, any>): void {
-     if (err instanceof Error) {
-      this.log('emerg', msg, context, err);
-    } else {
-      const combinedContext = { ...(err || {}), ...(context || {}) };
-      this.log('emerg', msg, combinedContext);
-    }
-  }
-
-  /** Log fatal message (alias for emergency, ensures process exit) */
-   public fatal(msg: string, context?: Record<string, any>, error?: Error): void {
-    this.log('emerg', msg, context, error);
-    // Optionally add logic here to ensure process termination after logging fatal error
-    // Be careful with async operations here if you intend immediate exit.
-    // process.exit(1); // Consider if this is appropriate for your application's shutdown logic
-  }
-}
-
-// Export singleton instance
-export const logger = Logger.getInstance();
-
-// Initialize logger on import (can be configured later via setLevel/setMcpNotificationSender)
-// Read initial level from env var or default to 'info'
-const initialLogLevel = (process.env.MCP_LOG_LEVEL as McpLogLevel) || 'info';
-logger.initialize(initialLogLevel);
diff --git a/src/utils/rateLimiter.ts b/src/utils/rateLimiter.ts
deleted file mode 100644
index 650aa0d..0000000
--- a/src/utils/rateLimiter.ts
+++ /dev/null
@@ -1,237 +0,0 @@
-import { BaseErrorCode, McpError } from '../types-global/errors.js';
-import { logger } from './logger.js';
-import { RequestContext } from './requestContext.js'; // Import the correct RequestContext
-
-/**
- * Rate limiting configuration options
- */
-export interface RateLimitConfig {
-  /** Time window in milliseconds */
-  windowMs: number;
-  /** Maximum number of requests allowed in the window */
-  maxRequests: number;
-  /** Custom error message template */
-  errorMessage?: string;
-  /** Whether to skip rate limiting in certain environments (e.g. development) */
-  skipInDevelopment?: boolean;
-  /** Custom key generator function */
-  keyGenerator?: (identifier: string, context?: RequestContext) => string;
-  /** How often to run cleanup of expired entries (in milliseconds) */
-  cleanupInterval?: number;
-}
-
-/**
- * Individual rate limit entry
- */
-export interface RateLimitEntry {
-  /** Current request count */
-  count: number;
-  /** When the window resets (timestamp) */
-  resetTime: number;
-}
-
-/**
- * Generic rate limiter that can be used across the application
- */
-export class RateLimiter {
-  /** Map storing rate limit data */
-  private limits: Map<string, RateLimitEntry>;
-  /** Cleanup interval timer */
-  private cleanupTimer: NodeJS.Timeout | null = null;
-  /** Default configuration */
-  private static DEFAULT_CONFIG: RateLimitConfig = {
-    windowMs: 15 * 60 * 1000, // 15 minutes
-    maxRequests: 100, // 100 requests per window
-    errorMessage: 'Rate limit exceeded. Please try again in {waitTime} seconds.',
-    skipInDevelopment: false,
-    cleanupInterval: 5 * 60 * 1000 // 5 minutes
-  };
-
-  /**
-   * Create a new rate limiter
-   * @param config Rate limiting configuration
-   */
-  constructor(private config: RateLimitConfig) {
-    this.config = { ...RateLimiter.DEFAULT_CONFIG, ...config };
-    this.limits = new Map();
-    this.startCleanupTimer();
-    
-    // Log initialization
-    logger.debug('RateLimiter initialized', {
-      windowMs: this.config.windowMs,
-      maxRequests: this.config.maxRequests,
-      cleanupInterval: this.config.cleanupInterval
-    });
-  }
-
-  /**
-   * Start the cleanup timer to periodically remove expired entries
-   */
-  private startCleanupTimer(): void {
-    if (this.cleanupTimer) {
-      clearInterval(this.cleanupTimer);
-    }
-    
-    const interval = this.config.cleanupInterval ?? RateLimiter.DEFAULT_CONFIG.cleanupInterval;
-    
-    if (interval) {
-      this.cleanupTimer = setInterval(() => {
-        this.cleanupExpiredEntries();
-      }, interval);
-      
-      // Ensure the timer doesn't prevent the process from exiting
-      if (this.cleanupTimer.unref) {
-        this.cleanupTimer.unref();
-      }
-    }
-  }
-  
-  /**
-   * Clean up expired rate limit entries to prevent memory leaks
-   */
-  private cleanupExpiredEntries(): void {
-    const now = Date.now();
-    let expiredCount = 0;
-    
-    // Use a synchronized approach to avoid race conditions during cleanup
-    for (const [key, entry] of this.limits.entries()) {
-      if (now >= entry.resetTime) {
-        this.limits.delete(key);
-        expiredCount++;
-      }
-    }
-    
-    if (expiredCount > 0) {
-      logger.debug(`Cleaned up ${expiredCount} expired rate limit entries`, {
-        totalRemaining: this.limits.size
-      });
-    }
-  }
-
-  /**
-   * Update rate limiter configuration
-   * @param config New configuration options
-   */
-  public configure(config: Partial<RateLimitConfig>): void {
-    this.config = { ...this.config, ...config };
-    
-    // Restart cleanup timer if interval changed
-    if (config.cleanupInterval !== undefined) {
-      this.startCleanupTimer();
-    }
-  }
-
-  /**
-   * Get current configuration
-   * @returns Current rate limit configuration
-   */
-  public getConfig(): RateLimitConfig {
-    return { ...this.config };
-  }
-
-  /**
-   * Reset all rate limits
-   */
-  public reset(): void {
-    this.limits.clear();
-    logger.debug('Rate limiter reset, all limits cleared');
-  }
-
-  /**
-   * Check if a request exceeds the rate limit
-   * @param key Unique identifier for the request source
-   * @param context Optional request context
-   * @throws {McpError} If rate limit is exceeded
-   */
-  public check(key: string, context?: RequestContext): void {
-    // Skip in development if configured
-    if (this.config.skipInDevelopment && process.env.NODE_ENV === 'development') {
-      return;
-    }
-
-    // Generate key using custom generator if provided
-    const limitKey = this.config.keyGenerator 
-      ? this.config.keyGenerator(key, context)
-      : key;
-
-    const now = Date.now();
-    
-    // Accessing and updating the limit entry within a single function scope
-    // ensures atomicity in Node.js's single-threaded event loop for Map operations.
-    const limit = () => {
-      // Get current entry or create a new one if it doesn't exist or is expired
-      const entry = this.limits.get(limitKey);
-      
-      // Create new entry or reset if expired
-      if (!entry || now >= entry.resetTime) {
-        const newEntry = {
-          count: 1,
-          resetTime: now + this.config.windowMs
-        };
-        this.limits.set(limitKey, newEntry);
-        return newEntry;
-      }
-      
-      // Check if limit exceeded
-      if (entry.count >= this.config.maxRequests) {
-        const waitTime = Math.ceil((entry.resetTime - now) / 1000);
-        const errorMessage = this.config.errorMessage?.replace('{waitTime}', waitTime.toString()) ||
-          `Rate limit exceeded. Please try again in ${waitTime} seconds.`;
-        
-        throw new McpError(
-          BaseErrorCode.RATE_LIMITED,
-          errorMessage,
-          { waitTime, key: limitKey }
-        );
-      }
-      
-      // Increment counter and return updated entry
-      entry.count++;
-      return entry;
-    };
-    
-    // Execute the rate limiting logic
-    limit();
-  }
-
-  /**
-   * Get rate limit information for a key
-   * @param key The rate limit key
-   * @returns Current rate limit status or null if no record exists
-   */
-  public getStatus(key: string): { current: number; limit: number; remaining: number; resetTime: number } | null {
-    const entry = this.limits.get(key);
-    
-    if (!entry) {
-      return null;
-    }
-    
-    return {
-      current: entry.count,
-      limit: this.config.maxRequests,
-      remaining: Math.max(0, this.config.maxRequests - entry.count),
-      resetTime: entry.resetTime
-    };
-  }
-  
-  /**
-   * Stop the cleanup timer when the limiter is no longer needed
-   */
-  public dispose(): void {
-    if (this.cleanupTimer) {
-      clearInterval(this.cleanupTimer);
-      this.cleanupTimer = null;
-    }
-    
-    // Clear all entries
-    this.limits.clear();
-  }
-}
-
-/**
- * Create and export a default rate limiter instance
- */
-export const rateLimiter = new RateLimiter({
-  windowMs: 15 * 60 * 1000, // 15 minutes
-  maxRequests: 100 // 100 requests per window
-});
diff --git a/src/utils/requestContext.ts b/src/utils/requestContext.ts
deleted file mode 100644
index 42f4c4f..0000000
--- a/src/utils/requestContext.ts
+++ /dev/null
@@ -1,91 +0,0 @@
-import { logger } from './logger.js';
-import { generateUUID } from './idGenerator.js'; // Import generateUUID
-// Removed incorrect import: import { RequestContext } from './rateLimiter.js';
-
-/**
- * Defines the structure for context information associated with a request or operation.
- */
-export interface RequestContext {
-  /** Unique identifier generated for the request context instance. */
-  requestId: string;
-  /** ISO 8601 timestamp indicating when the context was created. */
-  timestamp: string;
-  /** Allows for additional, arbitrary key-value pairs for specific context needs. */
-  [key: string]: any; // Allow flexible extension
-}
-
-/**
- * Configuration interface for request context utilities
- */
-export interface ContextConfig {
-  /** Custom configuration properties */
-  [key: string]: unknown;
-}
-
-/**
- * Operation context with request data
- */
-export interface OperationContext {
-  /** Request context data */
-  requestContext?: RequestContext;
-  /** Custom context properties */
-  [key: string]: unknown;
-}
-
-// Direct instance for request context utilities
-const requestContextServiceInstance = {
-  config: {} as ContextConfig,
-
-  /**
-   * Configure service settings
-   * @param config New configuration
-   * @returns Updated configuration
-   */
-  configure(config: Partial<ContextConfig>): ContextConfig {
-    this.config = {
-      ...this.config,
-      ...config
-    };
-    logger.debug('RequestContext configuration updated', { config: this.config });
-    return { ...this.config };
-  },
-
-  /**
-   * Get current configuration
-   * @returns Current configuration
-   */
-  getConfig(): ContextConfig {
-    return { ...this.config };
-  },
-
-  /**
-   * Create a request context with unique ID and timestamp
-   * @param additionalContext Additional context properties
-   * @returns Request context object
-   */
-  createRequestContext(
-    additionalContext: Record<string, unknown> = {}
-  ): RequestContext {
-    const requestId = generateUUID(); // Use imported generateUUID
-    const timestamp = new Date().toISOString();
-
-    return {
-      requestId,
-      timestamp,
-      ...additionalContext
-    };
-  },
-
-  // generateSecureRandomString function removed as it was unused and redundant
-};
-
-// Initialize logger message
-logger.debug('RequestContext service initialized');
-
-// Export the instance directly
-export const requestContextService = requestContextServiceInstance;
-
-// Removed delegate functions and default export for simplicity.
-// Users should import and use `requestContextService` directly.
-// e.g., import { requestContextService } from './requestContext.js';
-// requestContextService.createRequestContext();
diff --git a/src/utils/sanitization.ts b/src/utils/sanitization.ts
deleted file mode 100644
index e8e95b3..0000000
--- a/src/utils/sanitization.ts
+++ /dev/null
@@ -1,492 +0,0 @@
-import path from 'path';
-import sanitizeHtml from 'sanitize-html';
-import validator from 'validator';
-import { BaseErrorCode, McpError } from '../types-global/errors.js';
-import { logger } from './logger.js';
-
-/**
- * Options for path sanitization
- */
-export interface PathSanitizeOptions {
-  /** Restrict paths to a specific root directory */
-  rootDir?: string;
-  /** Normalize Windows-style paths to POSIX-style */
-  toPosix?: boolean;
-  /** Allow absolute paths (if false, converts to relative paths) */
-  allowAbsolute?: boolean;
-}
-
-/**
- * Context-specific input sanitization options
- */
-export interface SanitizeStringOptions {
-  /** Handle content differently based on context */
-  context?: 'text' | 'html' | 'attribute' | 'url' | 'javascript';
-  /** Custom allowed tags when using html context */
-  allowedTags?: string[];
-  /** Custom allowed attributes when using html context */
-  allowedAttributes?: Record<string, string[]>;
-}
-
-/**
- * Configuration for HTML sanitization
- */
-export interface HtmlSanitizeConfig {
-  /** Allowed HTML tags */
-  allowedTags?: string[];
-  /** Allowed HTML attributes (global or per-tag) */
-  allowedAttributes?: sanitizeHtml.IOptions['allowedAttributes'];
-  /** Allow preserving comments - uses allowedTags internally */
-  preserveComments?: boolean;
-  /** Custom URL sanitizer */
-  transformTags?: sanitizeHtml.IOptions['transformTags'];
-}
-
-/**
- * Sanitization class for handling various input sanitization tasks
- */
-export class Sanitization {
-  private static instance: Sanitization;
-  
-  /** Default list of sensitive fields for sanitizing logs */
-  private sensitiveFields: string[] = [
-    'password', 'token', 'secret', 'key', 'apiKey', 'auth', 
-    'credential', 'jwt', 'ssn', 'credit', 'card', 'cvv', 'authorization'
-  ];
-
-  /** Default sanitize-html configuration */
-  private defaultHtmlSanitizeConfig: HtmlSanitizeConfig = {
-    allowedTags: [
-      'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'a', 'ul', 'ol', 
-      'li', 'b', 'i', 'strong', 'em', 'strike', 'code', 'hr', 'br', 
-      'div', 'table', 'thead', 'tbody', 'tr', 'th', 'td', 'pre'
-    ],
-    allowedAttributes: {
-      'a': ['href', 'name', 'target'],
-      'img': ['src', 'alt', 'title', 'width', 'height'],
-      '*': ['class', 'id', 'style']
-    },
-    preserveComments: false
-  };
-
-  /**
-   * Private constructor to enforce singleton pattern
-   */
-  private constructor() {
-    logger.debug('Sanitization service initialized with modern libraries');
-  }
-
-  /**
-   * Get the singleton Sanitization instance
-   * @returns Sanitization instance
-   */
-  public static getInstance(): Sanitization {
-    if (!Sanitization.instance) {
-      Sanitization.instance = new Sanitization();
-    }
-    return Sanitization.instance;
-  }
-
-  /**
-   * Set sensitive fields for log sanitization
-   * @param fields Array of field names to consider sensitive
-   */
-  public setSensitiveFields(fields: string[]): void {
-    this.sensitiveFields = [...new Set([...this.sensitiveFields, ...fields])]; // Ensure uniqueness
-    logger.debug('Updated sensitive fields list', { count: this.sensitiveFields.length });
-  }
-
-  /**
-   * Get the current list of sensitive fields
-   * @returns Array of sensitive field names
-   */
-  public getSensitiveFields(): string[] {
-    return [...this.sensitiveFields];
-  }
-
-  /**
-   * Sanitize HTML content using sanitize-html library
-   * @param input HTML string to sanitize
-   * @param config Optional custom sanitization config
-   * @returns Sanitized HTML
-   */
-  public sanitizeHtml(input: string, config?: HtmlSanitizeConfig): string {
-    if (!input) return '';
-    
-    // Create sanitize-html options from our config
-    const options: sanitizeHtml.IOptions = {
-      allowedTags: config?.allowedTags || this.defaultHtmlSanitizeConfig.allowedTags,
-      allowedAttributes: config?.allowedAttributes || this.defaultHtmlSanitizeConfig.allowedAttributes,
-      transformTags: config?.transformTags
-    };
-    
-    // Handle comments - if preserveComments is true, add '!--' to allowedTags
-    if (config?.preserveComments || this.defaultHtmlSanitizeConfig.preserveComments) {
-      options.allowedTags = [...(options.allowedTags || []), '!--'];
-    }
-    
-    return sanitizeHtml(input, options);
-  }
-
-  /**
-   * Sanitize string input based on context.
-   *
-   * **Important:** Using `context: 'javascript'` is explicitly disallowed and will throw an `McpError`.
-   * This is a security measure to prevent accidental execution or ineffective sanitization of JavaScript code.
-   *
-   * @param input String to sanitize
-   * @param options Sanitization options
-   * @returns Sanitized string
-   * @throws {McpError} If `context: 'javascript'` is used.
-   */
-  public sanitizeString(input: string, options: SanitizeStringOptions = {}): string {
-    if (!input) return '';
-    
-    // Handle based on context
-    switch (options.context) {
-      case 'html':
-        // Use sanitize-html with custom options
-        return this.sanitizeHtml(input, {
-          allowedTags: options.allowedTags,
-          allowedAttributes: options.allowedAttributes ? 
-            this.convertAttributesFormat(options.allowedAttributes) : 
-            undefined
-        });
-          
-      case 'attribute':
-        // Strip HTML tags for attribute context
-        return sanitizeHtml(input, { allowedTags: [], allowedAttributes: {} });
-          
-      case 'url':
-        // Validate and sanitize URL
-        if (!validator.isURL(input, { 
-          protocols: ['http', 'https'],
-           require_protocol: true
-         })) {
-           // Return empty string for invalid URLs in this context
-           logger.warning('Invalid URL detected during string sanitization', { input });
-           return '';
-         }
-        return validator.trim(input);
-        
-      case 'javascript':
-        // Reject any attempt to sanitize JavaScript
-        logger.error('Attempted JavaScript sanitization via sanitizeString', { input: input.substring(0, 50) });
-        throw new McpError(
-          BaseErrorCode.VALIDATION_ERROR,
-          'JavaScript sanitization not supported through string sanitizer'
-        );
-        
-      case 'text':
-      default:
-        // Strip HTML tags for basic text context
-        return sanitizeHtml(input, { allowedTags: [], allowedAttributes: {} });
-    }
-  }
-
-  /**
-   * Sanitize URL with robust validation and sanitization
-   * @param input URL to sanitize
-   * @param allowedProtocols Allowed URL protocols
-   * @returns Sanitized URL
-   * @throws {McpError} If URL is invalid
-   */
-  public sanitizeUrl(input: string, allowedProtocols: string[] = ['http', 'https']): string {
-    try {
-      // First validate the URL format
-      if (!validator.isURL(input, { 
-        protocols: allowedProtocols,
-        require_protocol: true 
-      })) {
-        throw new Error('Invalid URL format or protocol');
-      }
-      
-      // Double-check no javascript: protocol sneaked in
-      const lowerInput = input.toLowerCase().trim();
-      if (lowerInput.startsWith('javascript:')) {
-        throw new Error('JavaScript protocol not allowed');
-      }
-      
-      // Return the trimmed, validated URL
-      return validator.trim(input);
-    } catch (error) {
-      throw new McpError(
-        BaseErrorCode.VALIDATION_ERROR,
-        error instanceof Error ? error.message : 'Invalid URL format',
-        { input }
-      );
-    }
-  }
-
-  /**
-   * Sanitize file paths to prevent path traversal attacks
-   * @param input Path to sanitize
-   * @param options Options for path sanitization
-   * @returns Sanitized and normalized path
-   * @throws {McpError} If path is invalid or unsafe
-   */
-  public sanitizePath(input: string, options: PathSanitizeOptions = {}): string {
-    try {
-      if (!input || typeof input !== 'string') {
-        throw new Error('Invalid path input: must be a non-empty string');
-      }
-      
-      // Apply path normalization using built-in path module
-      let normalized = path.normalize(input);
-      
-      // Prevent null byte injection
-      if (normalized.includes('\0')) {
-        throw new Error('Path contains null byte');
-      }
-      
-      // Convert backslashes to forward slashes if toPosix is true
-      if (options.toPosix) {
-        normalized = normalized.replace(/\\/g, '/');
-      }
-      
-      // Handle absolute paths based on allowAbsolute option
-      if (!options.allowAbsolute && path.isAbsolute(normalized)) {
-        // Remove leading slash or drive letter to make it relative
-        normalized = normalized.replace(/^(?:[A-Za-z]:)?[/\\]/, '');
-      }
-      
-      // If rootDir is specified, ensure the path doesn't escape it
-      if (options.rootDir) {
-        const rootDir = path.resolve(options.rootDir);
-        
-        // Resolve the normalized path against the root dir
-        const fullPath = path.resolve(rootDir, normalized);
-        
-        // More robust check for path traversal: ensure fullPath starts with rootDir + separator
-        // or is exactly rootDir
-        if (!fullPath.startsWith(rootDir + path.sep) && fullPath !== rootDir) {
-          throw new Error('Path traversal detected');
-        }
-        
-        // Return the path relative to the root
-        return path.relative(rootDir, fullPath);
-      }
-      
-      // Final validation - check for relative path traversal attempts if not rooted
-      if (normalized.includes('..')) {
-         // Resolve the path to see if it escapes the current working directory conceptually
-         const resolvedPath = path.resolve(normalized);
-         const currentWorkingDir = path.resolve('.'); // Or use a safer base if needed
-         if (!resolvedPath.startsWith(currentWorkingDir)) {
-            throw new Error('Relative path traversal detected');
-         }
-      }
-      
-       return normalized;
-     } catch (error) {
-      logger.warning('Path sanitization error', {
-        input,
-        error: error instanceof Error ? error.message : String(error)
-      });
-      
-      throw new McpError(
-        BaseErrorCode.VALIDATION_ERROR,
-        error instanceof Error ? error.message : 'Invalid or unsafe path',
-        { input }
-      );
-    }
-  }
-  
-  /**
-   * Sanitize a JSON string
-   * @param input JSON string to sanitize
-   * @param maxSize Maximum allowed size in bytes
-   * @returns Parsed and sanitized object
-   * @throws {McpError} If JSON is invalid or too large
-   */
-  public sanitizeJson<T = unknown>(input: string, maxSize?: number): T {
-    try {
-      if (typeof input !== 'string') {
-        throw new Error('Invalid input: expected a JSON string');
-      }
-      
-      // Check size limit if specified
-      if (maxSize !== undefined && Buffer.byteLength(input, 'utf8') > maxSize) {
-        throw new McpError(
-          BaseErrorCode.VALIDATION_ERROR,
-          `JSON exceeds maximum allowed size of ${maxSize} bytes`,
-          { size: Buffer.byteLength(input, 'utf8'), maxSize }
-        );
-      }
-      
-      // Validate JSON format using JSON.parse for stricter validation than validator.isJSON
-      const parsed = JSON.parse(input);
-      
-      // Optional: Add recursive sanitization of parsed object values if needed
-      // this.sanitizeObjectRecursively(parsed); 
-      
-      return parsed as T;
-    } catch (error) {
-      if (error instanceof McpError) {
-        throw error;
-      }
-      
-      throw new McpError(
-        BaseErrorCode.VALIDATION_ERROR,
-        error instanceof Error ? error.message : 'Invalid JSON format',
-        { input: input.length > 100 ? `${input.substring(0, 100)}...` : input }
-      );
-    }
-  }
-  
-  /**
-   * Ensure input is within a numeric range
-   * @param input Number or string to validate
-   * @param min Minimum allowed value (inclusive)
-   * @param max Maximum allowed value (inclusive)
-   * @returns Sanitized number within range
-   * @throws {McpError} If input is not a valid number
-   */
-  public sanitizeNumber(input: number | string, min?: number, max?: number): number {
-    let value: number;
-    
-    // Handle string input
-    if (typeof input === 'string') {
-      // Use validator for initial check, but rely on parseFloat for conversion
-      if (!validator.isNumeric(input.trim())) {
-        throw new McpError(
-          BaseErrorCode.VALIDATION_ERROR,
-          'Invalid number format',
-          { input }
-        );
-      }
-      value = parseFloat(input.trim());
-    } else if (typeof input === 'number') {
-      value = input;
-    } else {
-       throw new McpError(
-          BaseErrorCode.VALIDATION_ERROR,
-          'Invalid input type: expected number or string',
-          { input: String(input) }
-        );
-    }
-    
-    // Check if parsing resulted in NaN
-    if (isNaN(value) || !isFinite(value)) {
-      throw new McpError(
-        BaseErrorCode.VALIDATION_ERROR,
-        'Invalid number value (NaN or Infinity)',
-        { input }
-      );
-    }
-    
-    // Clamp the value to the specified range
-    if (min !== undefined && value < min) {
-      value = min;
-      logger.debug('Number clamped to minimum value', { input, min, value });
-    }
-    
-    if (max !== undefined && value > max) {
-      value = max;
-      logger.debug('Number clamped to maximum value', { input, max, value });
-    }
-    
-    return value;
-  }
-
-  /**
-   * Sanitize input for logging to protect sensitive information
-   * @param input Input to sanitize
-   * @returns Sanitized input safe for logging
-   */
-  public sanitizeForLogging(input: unknown): unknown {
-    try {
-      // Handle non-objects and null directly
-      if (!input || typeof input !== 'object') {
-        return input;
-      }
-      
-      // Use structuredClone for deep copy if available (Node.js >= 17)
-      // Fallback to JSON stringify/parse for older versions
-      const clonedInput = typeof structuredClone === 'function' 
-        ? structuredClone(input)
-        : JSON.parse(JSON.stringify(input));
-          
-      // Recursively sanitize the cloned object
-      this.redactSensitiveFields(clonedInput);
-      
-      return clonedInput;
-    } catch (error) {
-      logger.error('Error during log sanitization', { 
-        error: error instanceof Error ? error.message : String(error) 
-      });
-      // Return a placeholder if sanitization fails
-      return '[Log Sanitization Failed]';
-    }
-  }
-
-  /**
-   * Private helper to convert attribute format from record to sanitize-html format
-   */
-  private convertAttributesFormat(attrs: Record<string, string[]>): sanitizeHtml.IOptions['allowedAttributes'] {
-    // sanitize-html directly supports Record<string, string[]> for allowedAttributes per tag
-    return attrs;
-  }
-
-  /**
-   * Recursively redact sensitive fields in an object or array
-   */
-  private redactSensitiveFields(obj: unknown): void {
-    if (!obj || typeof obj !== 'object') {
-      return;
-    }
-    
-    // Handle arrays: iterate and recurse
-    if (Array.isArray(obj)) {
-      obj.forEach((item, index) => {
-        // If the item is an object/array, recurse. Otherwise, leave primitive values.
-        if (item && typeof item === 'object') {
-          this.redactSensitiveFields(item);
-        }
-      });
-      return;
-    }
-    
-    // Handle regular objects: iterate through keys
-    for (const key in obj) {
-      // Use hasOwnProperty to avoid iterating over prototype properties
-      if (Object.prototype.hasOwnProperty.call(obj, key)) {
-        const value = (obj as Record<string, unknown>)[key];
-        
-        // Check if this key matches any sensitive field pattern (case-insensitive)
-        const isSensitive = this.sensitiveFields.some(field => 
-          key.toLowerCase().includes(field.toLowerCase())
-        );
-        
-        if (isSensitive) {
-          // Mask sensitive value
-          (obj as Record<string, unknown>)[key] = '[REDACTED]';
-        } else if (value && typeof value === 'object') {
-          // Recursively process nested objects/arrays
-          this.redactSensitiveFields(value);
-        }
-        // Primitive values are left as is if not sensitive
-      }
-    }
-  }
-}
-
-// Create and export singleton instance
-export const sanitization = Sanitization.getInstance();
-
-// Removed the `sanitizeInput` object export for simplicity.
-// Users should import `sanitization` and call methods directly.
-// e.g., import { sanitization } from './sanitization.js';
-// sanitization.sanitizeHtml(input);
-// sanitization.sanitizePath(input);
-
-/**
- * Sanitize input for logging to protect sensitive information.
- * Kept as a separate export for convenience.
- * @param input Input to sanitize
- * @returns Sanitized input safe for logging
- */
-export const sanitizeInputForLogging = (input: unknown): unknown => 
-  sanitization.sanitizeForLogging(input);
-
-// Removed default export
diff --git a/src/utils/tokenCounter.ts b/src/utils/tokenCounter.ts
deleted file mode 100644
index 1616eec..0000000
--- a/src/utils/tokenCounter.ts
+++ /dev/null
@@ -1,142 +0,0 @@
-import { ChatCompletionMessageParam } from 'openai/resources/chat/completions';
-import { encoding_for_model, Tiktoken, TiktokenModel } from 'tiktoken';
-import { BaseErrorCode, McpError } from '../types-global/errors.js'; // Import BaseErrorCode and McpError
-import { ErrorHandler } from './errorHandler.js'; // Import ErrorHandler
-import { logger } from './logger.js';
-import { RequestContext } from './requestContext.js';
-
-// Define the model used specifically for token counting
-const TOKENIZATION_MODEL: TiktokenModel = 'gpt-4o'; // Note this is strictly for token counting, not the model used for inference
-
-/**
- * Calculates the number of tokens for a given text using the 'gpt-4o' tokenizer.
- * Uses ErrorHandler for consistent error management.
- *
- * @param text - The input text to tokenize.
- * @param context - Optional request context for logging and error handling.
- * @returns The number of tokens.
- * @throws {McpError} Throws an McpError if tokenization fails.
- */
-export async function countTokens(
-  text: string,
-  context?: RequestContext
-): Promise<number> {
-  // Wrap the synchronous operation in tryCatch which handles both sync/async
-  return ErrorHandler.tryCatch(
-    () => {
-      let encoding: Tiktoken | null = null;
-      try {
-        // Always use the defined TOKENIZATION_MODEL
-        encoding = encoding_for_model(TOKENIZATION_MODEL);
-        const tokens = encoding.encode(text);
-        return tokens.length;
-      } finally {
-        encoding?.free(); // Ensure the encoder is freed if it was successfully created
-      }
-    },
-    {
-      operation: 'countTokens',
-      context: context,
-      input: { textSample: text.substring(0, 50) + '...' }, // Log sanitized input
-      errorCode: BaseErrorCode.INTERNAL_ERROR, // Use INTERNAL_ERROR for external lib issues
-      rethrow: true // Rethrow as McpError
-      // Removed onErrorReturn as we now rethrow
-    }
-  );
-}
-
-/**
- * Calculates the number of tokens for chat messages using the ChatCompletionMessageParam structure
- * and the 'gpt-4o' tokenizer, considering special tokens and message overhead.
- * This implementation is based on OpenAI's guidelines for gpt-4/gpt-3.5-turbo models.
- * Uses ErrorHandler for consistent error management.
- *
- * See: https://github.com/openai/openai-cookbook/blob/main/examples/How_to_count_tokens_with_tiktoken.ipynb
- *
- * @param messages - An array of chat messages in the `ChatCompletionMessageParam` format.
- * @param context - Optional request context for logging and error handling.
- * @returns The estimated number of tokens.
- * @throws {McpError} Throws an McpError if tokenization fails.
- */
-export async function countChatTokens(
-  messages: ReadonlyArray<ChatCompletionMessageParam>, // Use the complex type
-  context?: RequestContext
-): Promise<number> {
-  // Wrap the synchronous operation in tryCatch
-  return ErrorHandler.tryCatch(
-    () => {
-      let encoding: Tiktoken | null = null;
-      let num_tokens = 0;
-      try {
-        // Always use the defined TOKENIZATION_MODEL
-        encoding = encoding_for_model(TOKENIZATION_MODEL);
-
-        // Define tokens per message/name based on gpt-4o (same as gpt-4/gpt-3.5-turbo)
-        const tokens_per_message = 3;
-        const tokens_per_name = 1;
-
-        for (const message of messages) {
-          num_tokens += tokens_per_message;
-          // Encode role
-          num_tokens += encoding.encode(message.role).length;
-
-          // Encode content - handle potential null or array content (vision)
-          if (typeof message.content === 'string') {
-            num_tokens += encoding.encode(message.content).length;
-          } else if (Array.isArray(message.content)) {
-            // Handle multi-part content (e.g., text + image) - simplified: encode text parts only
-            for (const part of message.content) {
-              if (part.type === 'text') {
-                num_tokens += encoding.encode(part.text).length;
-               } else {
-                // Add placeholder token count for non-text parts (e.g., images) if needed
-                // This requires specific model knowledge (e.g., OpenAI vision model token costs)
-                logger.warning(`Non-text content part found (type: ${part.type}), token count contribution ignored.`, context);
-                // num_tokens += IMAGE_TOKEN_COST; // Placeholder
-              }
-            }
-          } // else: content is null, add 0 tokens
-
-          // Encode name if present (often associated with 'tool' or 'function' roles in newer models)
-          if ('name' in message && message.name) {
-            num_tokens += tokens_per_name;
-            num_tokens += encoding.encode(message.name).length;
-          }
-
-          // --- Handle tool calls (specific to newer models) ---
-          // Assistant message requesting tool calls
-          if (message.role === 'assistant' && 'tool_calls' in message && message.tool_calls) {
-             for(const tool_call of message.tool_calls) {
-                // Add tokens for the function name and arguments
-                if (tool_call.function.name) {
-                    num_tokens += encoding.encode(tool_call.function.name).length;
-                }
-                if (tool_call.function.arguments) {
-                    // Arguments are often JSON strings
-                    num_tokens += encoding.encode(tool_call.function.arguments).length;
-                }
-             }
-           }
-
-          // Tool message providing results
-          if (message.role === 'tool' && 'tool_call_id' in message && message.tool_call_id) {
-             num_tokens += encoding.encode(message.tool_call_id).length;
-             // Content of the tool message (the result) is already handled by the string content check above
-          }
-        }
-        num_tokens += 3; // every reply is primed with <|start|>assistant<|message|>
-        return num_tokens;
-      } finally {
-        encoding?.free();
-      }
-    },
-    {
-      operation: 'countChatTokens',
-      context: context,
-      input: { messageCount: messages.length }, // Log sanitized input
-      errorCode: BaseErrorCode.INTERNAL_ERROR, // Use INTERNAL_ERROR
-      rethrow: true // Rethrow as McpError
-      // Removed onErrorReturn
-    }
-  );
-}
